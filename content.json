{"meta":{"title":"Weex","subtitle":null,"description":"A framework for building Mobile cross-platform UIs. Different from a \"web app\", \"HTML5 app\", or \"hybrid app\", you can use Weex to build a real mobile app. The code that you write is relatively simple, because you can build native applications just using HTML, CSS, Javascript. But underneath, the core of the application is Objective-C or Java. At the same time, Weex will provide a lot of native components or modules for developers to use.","author":"Jinjiang","url":"https://weex.apache.org"},"pages":[{"title":"Bug Report Guidelines","path":"bug-report-guidelines.html","permalink":"https://weex.apache.org/bug-report-guidelines.html","text":"Bug Report Guidelines#This document describes how to write a good Weex bug report. Good bug reports help developers to classify the priority and severity of a bug properly, which helps the bug get fixed as soon as possible. The more specific information you provide, the better your bug gets understood. Bug Report General Principles# Avoid duplicates: Search before you file a new one! Always test the latest available version before submitting a bug. One bug per report. State useful facts, not opinions or complaints. How to Write a Good Bug Report#A good bug report should include the following information: Title#The goal of title is to make the report searchable and uniquely identifiable. A bad example: List Crash A good Example: List Crashes when deleting a header Environment#Weex Version: Please identify the version of WeexSDK or Weex Playground or weex-toolkit you were using when the bug occurred Device environment: Please identify the device model, platform and OS version. e.g. , iPhone 6, iOS 10.3. Overview/Description#The overview or description of a bug report is to explain the bug in detail, including: Justifications of why this is a bug dotwe demo that can reproduce the bug Screenshots for visual bugs Stack traces for crash bugs Console logs or error messages which are relevant in the bug Steps to Reproduce#The aim to provide the reproducible steps is to enable developers to reproduce the bug in their own environment. Here’s an example: Step 1: Load the demo using Weex Playground Step 2: Scroll to the bottom of the list Step 3: Click the red button to delete a header Test Results#The test results, including Expected Result and Actual Result, will tell developers what’s wrong. Expected Result describes what should happen, and Actual Result describes what actually happens. Reference#This document is a modified version of [1]. [1] http://testthewebforward.org/docs/bugs.html","type":"community"},{"title":"How to Contribute","path":"contributing.html","permalink":"https://weex.apache.org/contributing.html","text":"How to Contribute#Apache Weex is an open source project which is under active development, developers can participate and contribute to the Apache Weex community in a variety of ways. Contributing doesn’t just mean contributing code, reporting bugs, answering questions, joining in discussions and contributing documentation are also welcome. Report Bugs#You can use Weex directly through Get Started tutorial. If you encounter any unexpected phenomena during your use, feel free to let us know by filing a bug report. Open a JIRA Issue , click on the top red “Create” button (you may need to create a JIRA account if you haven’t registered). Bug Report Guidelines document provides some of the most useful information about writing a good bug report. The better your bug report is, the faster we can reproduce and fix it! Ask or Answer Questions#For basic use problems and help, we suggest you ask questions on stackoverflow.com and mark them with weex tag. You can also view all Weex related issues, answer some of the questions if you can, this will also help you get familiar with basic concepts and common misunderstandings about Weex, which can be useful when contributing documentation or code. Join in Discussions#In Weex community, most discussions happen on the mailing list. Dev mailing list dev@weex.incubator.apache.org is the place where Weex developers exchange ideas and discuss new features, new releases and the development process. Contributors and developers should subscribe to this list and follow it in order to keep up to date on what’s happening in Weex.(subscribe) (unsubscribe) (archives) Contribute Documentation#Documentation with good quality is a great help to developers. If there is a powerful API that is not easy to use, it becomes useless. So, we welcome any contributions to help Weex’s documents become precise and easy to read. To make changes to the document, you can edit the corresponding Markdown file at the weex-site repository and create a pull request. Contribute Code#If you have already decided to start writing code in Weex and contributing your fix and features to the project, congratulations! You’re up and running. For details on starting to work on a code contribution, please read Development Process. How to Become a Committer#Committers are core members of the community who can access the project’s repository and modify its code, documentation and web sites, as well as accept the contributions of other developers. There’s no exact criteria for becoming a committer, we are looking for contributors who are actively involved in community contributions and who have continued interest in Weex. If you are interested in becoming a Weex committer, contact any existing committer and we will help you go through the invitation process.","type":"community"},{"title":"Development Process","path":"development-process.html","permalink":"https://weex.apache.org/development-process.html","text":"Development Process#This document describes how to contribute changes to the Weex source code. Below are the recommended steps. 1. Choose or Create a JIRA issue#Generally, Weex uses JIRA Issue to track all types of code changes and not just bug fixes, and uses Github pull requests to manage the review and merge of specific code changes. That is, JIRAs are used to describe what should be fixed or changed, and high-level approaches, and pull requests describe how to implement that change in the project’s source code. Be sure to search the issues before creating new ones to avoid duplication. If your change may be controversial, you may want to create a discussion in the weex-dev mailing list. Every pull request should correspond to a issue in JIRA. 2. Develop Your Changes# Fork the Github repository at https://github.com/apache/incubator-weex if you haven’t already. Clone your fork, create a new branch to push your commits to. Develop your feature or bug fix. Make sure your changes meet the code style guidelines. Copy and paste this to the top of your new file(s): /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ Documentation and tests should be added or referenced if they need to be added or updated as part of the change. Commit to your branch following commit guidelines. 3. Create a Pull Request#Open a pull request against the master branch of apache/incubator-weex. Make sure it meets these guidelines: One pull request for one issue The PR title should be of the form [WEEX-xxxx][COMPONENT] Summary, where xxxx is the relevant JIRA number, COMPONENT is one of the PR categories(android, iOS, jsfm, web, doc, website, example, test, other) and Title may be the JIRA’s title or a more specific title describing the PR itself. If the pull request is still a work in progress, and so is not ready to be merged, but needs to be pushed to Github to facilitate review, then add [WIP] after the component. Code Style Guidelines#Objective-C# Tabs for indentation(not spaces) * operator goes with the variable name (e.g. Type *variable;) Function definitions: place each brace on its own line. Other braces: place the open brace on the line preceding the code block; place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android# Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style. Commit Guidelines#Use the following form to write commit descriptions: Summary of change, same as PR title: `[WEEX-xxxx][COMPONENT] Summary`Longer description of change addressing as appropriate: why the changeis made,context if it is part of many changes, description of previous behavior and newly introduced differences, etc.Long lines should be wrapped to 80 columns for easier log message viewing interminals.Bug: 123456 A short subject and a blank line after the subject are crucial. Use the bug number from the JIRA issue. Some good thoughts on how to write good git commit messages can be found here.","type":"community"},{"title":"Resources","path":"resources.html","permalink":"https://weex.apache.org/resources.html","text":"About Weex Project# Weex Official Website (weex.apache.org). Mirror in Alibaba Cloud (weex-project.io), faster in China. Weex Project Incubation Status. Mailing List. Issues. Weex Contributing Guide A guidance document tells you how to be submitted by the person weex and how to participate in mailing discussions. Weex FAQ. Supported Front-end Frameworks# Rax Rax is a front-end framework with React-compatible APIs. Vue.js Vue.js is a progressive front-end framework for building user interfaces. Components and Modules# Weex Ui Weex Ui is a rich interaction, lightweight, high performance UI library. Weex Market A website that provides a quick porting of weex’s third-party component list, where you can find the weex components you need for integration. Tools# Online Playground A website provides weex code practice and preview, as well as a convenient sharing platform. Playground App You can preview weex on the Playground App and learning how to use weex on it. Weex Language support for Intellij A plugin supports Weex Language for Intellij. Community# SegmentFault (cn) StackOverflow Telegram Russian Community Group Gitter for weex-en Posts# Weex Articles(cn). Examples# Weex Vue Examples","type":"community"},{"title":"Who is Using Weex?","path":"who-is-using-weex.html","permalink":"https://weex.apache.org/who-is-using-weex.html","text":"","type":"community"},{"title":"","path":"cn/blog.html","permalink":"https://weex.apache.org/cn/blog.html","text":"","type":"blog"},{"title":"Bug 报告指南","path":"cn/bug-report-guidelines.html","permalink":"https://weex.apache.org/cn/bug-report-guidelines.html","text":"Bug 报告指南#该文档描述了如何编写一个好的 Weex bug 报告。好的 bug 报告帮助开发者决定一个 bug 的优先级和严重性，并且增加了 bug 被快速修复的可能性，你能提供的具体信息越多越好。 Bug 报告原则# 避免重复:在报 bug 前先搜索! 总是测试最新的可用版本。 每个报告只报一个 bug。 陈述有用的事实，而不是意见或抱怨。 如何编写一个好的 Bug 报告#一个好的 bug 报告应该包括以下信息: 标题#标题的目标是使 bug 能够被搜索并且唯一可识别。 一个坏的例子:List Crash 一个很好的例子:List Crashes when deleting a header 环境#Weex 版本: 请告知你在 bug 发生时使用的 WeexSDK 、Weex Playground 或 weex-toolkit 的版本 设备环境: 请告知你 bug 所发生的机型、平台和 OS 版本，例如：iPhone 6,iOS 10.3。 概述/描述#bug 报告的概述或描述是向开发者详细解释 bug，包括： 为什么这是一个 bug 可以重现 bug 的 dotwe 链接 在视觉上可感知的 bug， 可以提供截屏 对于 crash bug， 可以提供详细的堆栈 复现步骤#复现步骤的目标是帮助开发者在他自己的系统上重现 bug ，例如： 步骤1：使用 Weex playgroud 扫码打开上面提供的 dotwe 链接 步骤2：滚动到列表底部 步骤3：点击红色按钮删除头部组件 测试结果#测试结果，包括预期结果和实际结果，预期结果描述了应该发生的事情，实际结果描述了实际发生的事情，从而表明这是个 bug 。","type":"community"},{"title":"如何参与贡献","path":"cn/contributing.html","permalink":"https://weex.apache.org/cn/contributing.html","text":"如何参与贡献#Apache Weex 是一个活跃的开源项目，开发者可以通过多种方式参与和贡献 Apache Weex 社区。贡献并不仅仅意味着贡献代码，报bug、回答问题、参与讨论以及帮助提升文档质量也都属于贡献的一部分。 报 Bug#直接通过快速上手教程开始使用 Weex，如果在使用过程中遇到任何问题和不符合预期的现象，都可以通过写一个 bug 报告来反馈。 打开 JIRA Issue ，点击最上方红色的 “Create” 按钮（如果还没有注册 JIRA 账号则需要先注册一下）， Bug 报告指南 文档提供了一些关于 Bug 报告中最有用的信息的细节提示。你的 Bug 报告写得越好，我们就能越快地重现和修复它！ 提问或者回答问题#对于使用上的问题，建议你在 stackoverflow.com 平台上提问， 记得用 weex 标签标记它们。 你也可以查看所有的 Weex相关问题，如果可以的话，尽可能帮助回答一些问题，这些问题常常是新手需要了解的基本概念和常见问题， 这也将帮助你更好地熟悉和使用 Weex 。 参与邮件组讨论#在 Weex 社区，大多数讨论都发生在邮件列表上。 dev 邮件组 dev@weex.incubator.apache.org 是 Weex 开发人员交流和讨论新功能、新发布、开发流程的地方。 贡献者和开发者都应该订阅这个邮件组，以便了解到 Weex 项目所发生的事情以及表达自己的观点。 (订阅) (退订) (档案) 帮助提升文档质量#质量好的文档对开发者是极大的帮助。如果有一个功能强大的 API 但不易于使用，它就会变得毫无用处。所以， 我们欢迎任何贡献以帮助 Weex 的文档变得精确和易于阅读。 想要对文档进行更改，可以在 weex-site 仓库编辑对应的 Markdown 文件并创建一个 Pull Request. 贡献代码#如果你已经决定开始在 Weex 中编写代码，并为项目贡献你的修复和新特性， 在你从你 fork 的仓库提交一个 pull request 之前，请一定遵循我们的 开发流程。 如何成为 Committer#Apache committer 是社区的核心成员，他们可以访问项目的仓库，也可以自己修改代码、文档和网站，也可以接受其他开发者的贡献。 我们正在招募 committer，我们所寻找的是积极参与到社区贡献同时对 Weex 有持续兴趣的同学。如果你有兴趣成为一名 Weex committer，可以联系现有的 committer 或者直接联系 dev 邮件组，欢迎你的加入！","type":"community"},{"title":"开发流程","path":"cn/development-process.html","permalink":"https://weex.apache.org/cn/development-process.html","text":"开发流程#本文档描述了如何对 Weex 源代码进行更改和提交，以下是建议的步骤： 1. 选择或创建一个 JIRA issue单#目前 Weex 使用 JIRA Issue 来跟踪所有类型的代码更改，而不仅仅是 bug 修复，我们使用 Github Pull Request 来管理代码 review 和合并特定的代码更改。也就是说，JIRA用于描述什么是需要修复或更改的，Pull Request 用于描述这些修复和变更如何实现。 在创建新问题之前一定要先搜索问题，避免重复。如果你的更改可能需要和其他开发者进行讨论，你可以在 weex-dev 邮件列表中创建一个讨论。 每个 PR 都应该对应于 JIRA 中的一个 issue。 2. 编写代码# Fork 在 https://github.com/apache/incubator-weex 上的 Github 仓库 Clone 你 fork 出来的仓库，创建一个新的分支用于提交变更 编写需要开发的特性或 bug 修复代码，确保你的更改符合代码风格指南。 复制并粘贴下面的注释到你的新文件顶部: /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ 修改或添加该变更相关de的文档和测试。 提交符合 commit 指南 的 commit 到你的分支。 3. 创建一个 Pull Request#创建一个 pull request 并提交到 apache/incubator-weex 的 master 分支，确保它符合这些准则: 一个 Pull Request 只解决一个问题 PR标题应该是 [WEEX-xxxx][模块]标题，其中 xxxx 是相关的 JIRA 问题号，模块是 PR 的类别（android、iOS、jsfm、web、component、doc、website、test、other），标题可以是 JIRA 的标题，也可以是描述 PR 本身的更具体的标题。 如果该 PR 相关的工作还在进行中，还没有准备好被合并，但需要被推到 Github 上以方便查看，可以在模块后添加 [WIP] 标示。 代码风格指南#Objective-C# 用 tab 缩进而不是空格 * 操作符靠近变量名（如 Type *variable） 方法定义：大括号需要另起一行 其他大括号：开括号紧跟在代码后面，不另起一行，闭括号单独占一行 使用 #pragma marks 标记将方法分类 遵循 GitHub Objective-C Style Guide 中其他的代码风格指南 Java &amp; Android# 使用 Google Java Style 作为基本的 Java 代码风格指南 其他 android 相关代码需遵循 AOSP Code Style Commit 指南#使用下面的形式来写 commit 描述: Summary of change, same as PR title: `[WEEX-xxxx][COMPONENT] Summary`Longer description of change addressing as appropriate: why the changeis made,context if it is part of many changes, description of previous behavior andnewly introduced differences, etc.Long lines should be wrapped to 80 columns for easier log message viewing interminals.Bug: 123456 一个简短的主题紧跟一个空行再接着写 commit 的详细描述，Bug 这里使用的是来自 JIRA 的问题号。 在这里可以找到一些关于如何编写 commit message 的好方法。","type":"community"},{"title":"资源","path":"cn/resources.html","permalink":"https://weex.apache.org/cn/resources.html","text":"","type":"community"},{"title":"谁在使用 Weex？","path":"cn/who-is-using-weex.html","permalink":"https://weex.apache.org/cn/who-is-using-weex.html","text":"","type":"community"},{"title":"Create a plugin","path":"guide/create-a-plugin.html","permalink":"https://weex.apache.org/guide/create-a-plugin.html","text":"The weex plugin development kit is designed to help developers build weex plugins quickly and easily, allowing them to integrate native functionality without changing business code. The plugin abstracts a functionality and/or component to the rest of the app by including the specific implementation for each target platform (Web, Android and iOS) and exposing it through a common API. Getting started#Create a weex plugin with weexpack:weex plugin create weex-my-plugin This will create a project structure similar to this:├── android (Android native code project)│ └── ...├── ios (iOS native code project)│ └── ...├── js (html5 project)│ └── ...├── examples (sample app)│ └── index.vue├── playground (sample projects to test the plugin)│ ├── android│ ├── browser│ └── ios├── WeexMyPlugin.podspec (iOS .podspec)├── package.json├── README.md The examples directory contains a weex app that you can use to test your plugin. This test app will be loaded from the playground apps that are installed in the playground folder. Web#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:web Webpack will be listening for changes in examples/index.vue and re-build the example app for you. The app will be served in the port 12580 (e.g. http://localhost:12580). Edit the plugin JavaScript/HTML/CSS code under the js folder. Refresh the test app to update the plugin in the playground app. Extending Web functionality#See Extend Web Render. Android#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:native Webpack will be listening for changes in examples/index.vue and re-build the example app for you. Open the android project under playground/android with Android Studio. The native plugin code will be linked as a gradle dependency. You can develop and test the plugin directly from Android Studio. You can also use weex debug to debug the playground app. Extending native functionality#See Extend Android. iOS#Developing and testing with the playground app# Build the example weex app in examples/index.vue: npm run start:native Webpack will be listening for changes in examples/index.vue and re-build the example app for you. Open the iOS playground app and install the dependencies: cd playground/iospod install Open WeexDemo.xcworkspace in Xcode. The native plugin code will be linked as cocoa pod. You can develop and test the plugin directly from Xcode. You can also use weex debug to debug the playground app. Extending native functionality#See Extend iOS. Publishing a plugin to the cocapods repository# Edit the *.podspec generated in the root of the plugin project. Check the correctness of the iOS plugin: pod spec lint --allow-warnings Publish to cocoapods repository: pod trunk push --allow-warnings Publish the plugin in the weex market#You can publish to the Weex Market with the simple command:weex plugin publish How to use the plugin in another project#Using weexpack:#weex plugin add weex-kdp Manual integration:#iOS:#pod &apos;WeexMyPlugin&apos; Android:#Add the following line to the dependencies list in the build.gradle file for the corresponding project.compile &apos;$&#123;groupId&#125;:weexkdp:&#123;$version&#125;&apos; Note: You need to specify the groupId and $version of the project. Web integration#npm install weexkdp","type":"guide"},{"title":"Extend Android","path":"guide/extend-android.html","permalink":"https://weex.apache.org/guide/extend-android.html","text":"Android extend# Weex supports module-extend、component-extend and adapter-extend. Module extend# Customize modules class must extend from WXModule. Extended method must add @JSMethod (uiThread = false or true) annotation, which determines whether the method is run on UI thread. The access level of mehtod must be public. Do not obfuscate code using tools like ProGuard. Extended method suppport the data type of int, double, float, String, Map, List as its param. Register the module: WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class);or else may report an error: ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;xxx&#39; . Refer to the following example: public class MyModule extends WXModule&#123; //run ui thread @JSMethod (uiThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; //run JS thread @JSMethod (uiThread = false) public void fireEventSyncCall()&#123; //implement your module logic here &#125;&#125; Register the module WXSDKEngine.registerModule(\"MyModule\", WXEventModule.class); Use this module in weex DSLNow event moudle is avaiable in weex, use the module like this: &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;testMyModule&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('myModule').printLog(\"I am a weex Module!\"); &#125; &#125; &#125;&lt;/script&gt; Javascript callback#If the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @WXModuleAnnopublic void openURL(String url,JSCallback callback)&#123; //implement your module logic here Map&lt;String,Object&gt; resp = new HashMap(); resp.put(\"result\",\"ok\"); callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extend# Customize components must extend from WXComponent or WXContainer Use the @WXComponentProp(name = value(value is attr or style)) annotation to let the update of attribute or style be recognized automatically. The access levels of mehtod must be public Customize can not be obfuscated by tools like ProGuard Component method with the annotation of @JSMethod can Weex params can be int, double, float, String, Map, List, Array Register your Component by WXSDKEngine.registerComponent Refer to the following example public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; Register your Component： WXSDKEngine.registerComponent(\"MyView\",MyViewComponent.class); Use this component in weex DSL： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; Extend Component Method# WeexSDK (0.9.5+) support the component method that can be invoked for example： @JSMethodpublic void focus()&#123; //method implementation&#125; after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; Extend adapter#ImagedownloadAdapter#Weex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examplepublic class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; Proguard Rules#If you want to using proguard to protect your source code, please add the following rules to your profile: -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;-keep class com.taobao.weex.bridge.**&#123;*;&#125;-keep class com.taobao.weex.dom.**&#123;*;&#125;-keep class com.taobao.weex.adapter.**&#123;*;&#125;-keep class com.taobao.weex.common.**&#123;*;&#125;-keep class * implements com.taobao.weex.IWXObject&#123;*;&#125;-keep class com.taobao.weex.ui.**&#123;*;&#125;-keep class com.taobao.weex.ui.component.**&#123;*;&#125;-keep class com.taobao.weex.utils.**&#123; public &lt;fields&gt;; public &lt;methods&gt;; &#125;-keep class com.taobao.weex.view.**&#123;*;&#125;-keep class com.taobao.weex.module.**&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep class * implements com.taobao.weex.ui.IExternalComponentGetter&#123;*;&#125;","type":"guide"},{"title":"Extend iOS","path":"guide/extend-ios.html","permalink":"https://weex.apache.org/guide/extend-ios.html","text":"Notice#All of the exported APIs in Weex are controllable and safe, they can not access private APIs or do any system hacks at runtime, neither can they change the primary purpose of the Application. If you are extending your custom modules/components, be sure NOT to export the ability of Objective-C runtime, be sure NOT to export dynamic and uncontrolled methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), be sure NOT to export any private methods. Module extend#Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module following the steps below. Step to customize a module# Module customized must implement WXModuleProtocol A macro named WX_EXPORT_METHOD must be added, as it is the only way to export methods to JavaScript. The weexInstance should be synthesized. Each module object is bind to a specific instance. Module methods will be invoked in UI thread, so do not put time consuming operation there. If you want to execute the whole module methods in other thread, please implement the method - (NSThread *)targetExecuteThread in protocol. In the way, tasks distributed to this module will be executed in targetExecuteThread. Weex params can be String or Map. Module supports to return results to Javascript in callback. This callback is type of WXModuleCallback, the params of which can be String or Map. @implementation WXEventModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end export synchronous methods v0.10+#If you want to export synchronous methods which could make Javascript receive return values from natvie, you can use WX_EXPORT_METHOD_SYNC macro. native code: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString))- (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js code: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" You can alse return number/array/dictionary except string. notice: the exported synchronous native method can only be called on JS thread. Do not do heavy work which will block js execution. notice: Vue 2.0 has not supported this feature yet. It will be supported in version 0.12 at the soonest. Register the module#You can register the customized module by calling the method registerModule:withClass in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; Handler extend#Weex SDK doesn’t have capabilitis, such as image download 、navigator operation，please implement these protocols by yourself. WXImgLoaderProtocol#Weex SDK has no image download capability, you need to implement WXImgLoaderProtocol. Refer to the following examples. WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished. */ -(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock; @end Implement above protocol as follows. @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end Register the handler#You can register the handler which implements the protocol by calling registerHandler:withProtocol in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; Custom Native Components for iOS#Component extend#There are a lot of native components ready to be used in the Weex SDK, but users always have their own use cases. You might have written an awesome native UI widget in your previous work and just want to wrap up it and export to Weex. So we provide a way to enable developers to create their own custom fully-native components. This guide will use the implementation of existing component image to show you how to build a native component. It will also assume that you are familiar with iOS programming. Registration#Defining a custom native component is simple. Just call [WXSDKEngine registerComponent:withClass:] with the component’s tag name as first argument. [WXSDKEngine registerComponent:@&quot;image&quot; withClass:[WXImageComponent class]]; Then you can create a WXImageComponent class to represent the implementation of image component. Now you can use &lt;image&gt; wherever you want in the template. &lt;image&gt;&lt;/image&gt; Adding Properties#The next thing we can do is to extend some native properties to make the component more powerful. As an image, let’s say we should have a src attribute as image’s remote source and a resize attribute as image’s resize mode(contain/cover/stretch). @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end All of the styles, attributes and events will be passed to the component’s initialization method, so here you can store the properties which you are interested in. @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; &#125; return self;&#125;@end The properties getted in the attributes are of id type, so we have to convert them to the type we want using a conversion function. Basic conversion functions can be found in the WXConvert file, or you can just add your own conversion function. Hooking Render Life Cycle#A Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. method description initWithRef:type:… Initializes a new component using the specified properties. layoutDidFinish Called when the component has just laid out. loadView Creates the view that the component manages. viewWillLoad Called before the load of component’s view . viewDidLoad Called after the component’s view is loaded and set. viewWillUnload Called just before releasing the component’s view. viewDidUnload Called when the component’s view is released. updateStyles: Called when component’s style are updated. updateAttributes: Called when component’s attributes are updated. addEvent: Called when adding an event to the component. removeEvent: Called when removing an event frome the component. As in the image component example, if we need to use our own image view, we can override the loadView method. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; Now Weex will use WXImageView to render the image component. As an image component, we will need to fetch the remote image and set it to the image view. This can be done in viewDidLoad method when the view is created and loaded. viewDidLoad is also the best time to perform additional initialization for your view， such as content mode changing. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; If image’s remote source can be changed, you can also hook the updateAttributes: method to perform your attributes changing logic. Component’s view always has been loaded while updateAttributes: or updateStyles: is called. - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; Maybe there is even more life cycle hooks you might need to consider, such as layoutDidFinish while layout computing is finished. If you want to go deeper, check out the WXComponent.h file in the source code. Now you can use &lt;image&gt; and its attributes wherever you want in the template. &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; Component Method#from WeexSDK 0.9.5, you can define your component method by macro WX_EXPORT_METHODfor example: @implementation WXMyComponent +WX_EXPORT_METHOD(@selector(focus)) +- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self; &#125; - (void)focus &#123; NSLog(@&quot;you got it&quot;); &#125;@end after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"Extend JS framework","path":"guide/extend-js-framework.html","permalink":"https://weex.apache.org/guide/extend-js-framework.html","text":"Extend JS framework#This part of the extension of JS framework is still in the discussion, may be adjusted at any time, please pay attention. Weex wants to be able to respect as many developer development habits as possible.So, in addition to Weex official support Vue 2.0, the developer can also customize and horizontally extension their own or their favorite JS Framework.The steps to customize the JS Framework are as follows: First you have a complete set of JS Framework. Learn about Weex’s JS engine feature support. Adapting Weex’s native DOM APIs. Adapting Weex’s initialization portal and multi-instance management mechanism. Add your own JS Framework to the framework configuration of the Weex JS runtime. Then pack it. Build JS bundles based on the JS Framework. You need to add a specific prefix comment so that the Weex JS runtime can recognize it. Weex JS engine features support# Under iOS, Weex uses the JavaScriptCore that comes with the system, so the ES support depends on the version of the operating system.The current conservative judgments, ES5 features on the market mainstream iOS devices are perfectly supported, but some of the features of ES6 + is not supported. Under Android, Weex uses the v8 kernel provided by UC. For performance and stability considerations, we are not using the latest version of the v8 kernel.The same conservative judgment, the ES5 feature can all support, including strict mode Object.freeze and so on. The Weex JS engine does not support HTML DOM APIs and HTML5 JS APIs, including document, setTimeout`, and so on. We added Promise‘s polyfill, as well as the console‘s polyfill. In addition, in order to ensure that the JS engine can manage memory as much as possible, we have a generic global object for the Object.freeze () freeze operation, which includes: Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype Adapt to Weex’s initial entry and multi-instance management mechanism#The JS Framework provided by the developer needs to be packaged as a CommonJS package, and the package needs to be extension to the following methods: Framework initialization# init(config) config Document Element Comment TaskSender CallbackManager This method places the Native DOM class and two auxiliary classes provided by Weex in the config parameter and allows the framework itself to be initialized. Tip: At the same time, the author can pass in a different config in the framework of the initialization time. This allows for framework testing or environmental simulation. Introduction to parameter format# TaskSender: wip… CallbackManager: wip… Register available native components and modules# registerComponents(components) registerModules(modules) These two methods are called immediately after the frame is initialized. This framework will be able to know which components and modules the current client supports. Introduction to parameter format# components: Array: Describe the array of components, each of which includes: type: string: Component name, for example div。 methods: string[]: Optional, a list of method names supported by this component. These methods can follow the native DOM APIs call. modules: Object: Describe the hash table of a series of modules. Key is the module name, the value is an array. The elements of the array describe a method in the module. The information of the method includes: name: string: Method name args: string[]: Parameter number and type description E.g: registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) Multi - instance lifecycle management# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) Each Weex page has two stages: created and destroyed. At the same time in the Weex page running process, native can send messages to the Weex page. Different frameworks can follow their own ideas to achieve the message. Introduction to parameter format# instanceId: string: The unique id of the Weex page is generated by native. code: string:The Wex page’s JS bundle’s code is passed through native. config: Object?: The configuration information for the Wex page, such as the bundleUrl representing the bundle address, is generated by the native configuration. It has nothing to do with the contents of the JS bundle itself. data: Object?: Native can import an external data when creating a Weex page. The JS framework can also generate different page content for the same JS bundle with different data. env: Object?:The current environment information about the Weex page, the meaning of each field: info: Object: Framework information, see the “JS Bundle format requirements” later. config: Object:Equivalent to the third parameter of the method config callbacks: CallbackManager: only CallbackManagerinstance of Weex page. created: number:The number of seconds that the Wex page was created. framework: string:The name of the framework used by the Wex page. Equivalent to info.framework. Native communication# receiveTasks(instanceId, tasks) Native can use the refreshInstance method to send a message to the JS framework layer. But in many cases will use receiveTasks to send user events or methods callback to the JS framework. For example, if the user clicks on a button, native will send a fireEvent type of task to the JS framework, and then the JS framework will handle the corresponding event logic. This part of the working mechanism is related to the design of the addEvent in the native DOM interface. Another example is the user using fetch to send network requests. When the request is done at the native end, it will be sent to the JS framework with a callback type of task. Since native can not pass the function in JavaScript, it actually only sends a callbackId to the JS framework. This part of the working mechanism is related to the design of CallbackManager. Auxiliary method# getRoot(instanceId): JSON This method returns the full JSON description of the document body node. Developers can view the full native DOM tree as a result. The format of the specific return value is the same as the return method of the toJSON () method in the native DOM interface. This feature is used extensively as a developer tool extension. Configure the JS Framework in WeexSDK#Prepare your JS Framework code#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; Register a JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; And then packaged JS runtime, integrated into WeexSDK. JS Bundle format requirements#Framework infoThe note(alias framework info) at the beginning of the JS Bundle file is very important. The format is as follows: // &#123; \"framework\": \"Vue\" &#125; So that the Weex JS engine will know that the JS bundle needs to use the Vue framework to resolve.Similarly, Weex supports multiple frameworks.It will be based on js bundle notes to select the corresponding framework resolution.","type":"guide"},{"title":"Extend Web Renderer","path":"guide/extend-web-render.html","permalink":"https://weex.apache.org/guide/extend-web-render.html","text":"Extend Web components#Vue.js is an independent front-end framework. In the browser, you can not use the Weex container for page rendering. So, the two things are the same: (1) for the Weex platform to expand Vue.js Web components. (2) directly using Vue.js to develop a Web component. The development of components can refer to its documentation: component. It is also recommended to use the .vue file to write components. How to use it: Single file component. Extend Web renderer’s built-in components#Weex itself offers a lot of built-in components and modules, but also has the ability to expand horizontally. It allows developers to expand and customize themselves. But it is important to note that Weex is a cross-platform solution. When extending its built-in components or modules, you need to implement it on the three ends (Android, iOS, Web). After Weex switches the kernel to Vue 2.x, it will be easier to extend the Vue component on the Web side. We current use weex-vue-render for Vue 2.x Web side rendering. Firstly import this library in your web page, then you can extend the render’s built-in components using weex.registerComponent or Vue.component. Basically these two methods are doing the same thing. Example of extension for weex built-in components.#To extend &lt;sidebar&gt; as an example, you should first write the logic of the component itself: &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; And then register the &lt;sidebar&gt; component globally before using it: import Vue from 'vue'import weex from 'weex-vue-render'import Sidebar from './path/to/sidebar.vue'weex.init(Vue)// register the `&lt;sidebar&gt;` component globallyweex.registerComponent('sidebar', Sidebar)// or:// Vue.component('sidebar', Sidebar) When you extend the Weex component, if you only use the built-in components provided by Weex and use the styles that Weex supports, it is no different from the normal custom component and does not need to be implemented at the Native side. If you find a component that does not support labels and styles that are not supported by Weex, you will need to really extend the Weex component. At the same time, you also need to extend in the Android side and the iOS side, or will lead to rendering exception. Extend the Web module#In addition to the common components, Weex also provides a common module, you can easily call the native API. In general, the registered Weex module requires three ends to be implemented, otherwise it will affect its normal use. Register the module#If we import the weex-vue-render library, we can get the weex variable globally. You can register the module using the registerModulemethod. API format# registerModule name: {String} Required, module name. define: {Object} Required, module definition. meta: {Object} Optional, module meta info. Basically you won’t need this except you want to pass a non iterable attribute or method from your module implementation object. In this case you should pass a { registerType: &#39;assignment&#39; } object to it. Otherwise only the iterables will be registered in the module. The example of register module#The following code registers a module called guide: weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) Use the module#Weex provides the require method for getting registered modules. You only need to pass the module name directly: //import moduleconst guide = weex.requireModule('guide')// use the methods of moduleguide.greeting()guide.farewell() The above wording is as useful as the native end, except that the methods in the module are provided by Native.","type":"guide"},{"title":"Front-End Frameworks","path":"guide/front-end-frameworks.html","permalink":"https://weex.apache.org/guide/front-end-frameworks.html","text":"Front-end Frameworks in Weex Vue.js Rax Front-end Frameworks in Weex#Front-end technologies seem flourishing and productive. Using front-end frameworks in production is a good way to manage apps wr. industry. collaborate, maintainable. However, Weex is not a front-end framework. Indeed, front-end frameworks are just the syntax layer or DSL (Domain-specific Language) of Weex, they are decoupled from native render engines. In another word, Weex does not relay on any specific front-end frameworks, with the evolution of technology, Weex can integrate more widely used front-end frameworks as well. Currently, Weex mainly supports Vue.js and Rax, and those frameworks are already integrated into Weex SDK, you don’t need to require them manually. Learn some basics of Vue.js or Rax could be very helpful when you are using Weex. It is better to learn some basics of Vue.js or Rax before using Weex. Vue.js#Weex integrated the v2 version of Vue.js since WeexSDK v0.10.0 is released at 2016/02/17. Vue (pronounced /vjuː/, like view) is a progressive front-end framework for building user interfaces. Please refer to its official website for more information. Please refer to Use Vue.js on Weex document to learn more technics about Weex and Vue. Rax#Rax is a front-end framework with React-compatible APIs. Please refer to Rax’s official website to get more information.","type":"guide"},{"title":"Integrate Devtool to Android","path":"guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-android.html","text":"Integrate Devtool to Android#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your Android App. Integrate to Android#Installing Dependencies#Weex Devtools depend on weex_inspector. I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. There are two choices to install it: From Gradle dependencies &#123; compile 'com.taobao.android:weex_inspector:0.13.2'&#125; From source code you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(':inspector')&#125; Version compatibility# weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 0.16.0+ 0.12.1 - 0.17.0+ 0.13.2 - Adding Debug mode switch#The key to control the opening and closing of the debug mode can be summarized as three rules: No.1: Set the switch and Debugger Server addresses via sRemoteDebugMode and sRemoteDebugProxyUrl. WXEnvironment class has a pair of static variables mark Weex current debug mode: public static boolean sRemoteDebugMode; // default closepublic static String sRemoteDebugProxyUrl; // Debugger Server addresses You have to set WXEnvironment.sRemoteDebugMode and WXEnvironment.sRemoteDebugProxyUrl at the right time, for example: private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; You can find detail and suitable way of initialize inspector in Playground. No.2: You must call WXSDKEngine.reload() method when sRemoteDebugMode was changed. You can control a state of debug mode via the WXEnvironment.sRemoteDebugMode, but you need reset Weex runtime if you changed a state of debug mode. private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; In this way, You can control the debug mode flexibly. No.3: Auto refresh page via ACTION_DEBUG_INSTANCE_REFRESH broadcast ACTION_DEBUG_INSTANCE_REFRESH can be broadcast messages when the debug mode is switched or Chrome page refresh. You can use this mechanism to inform the current page to refresh in time. public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; Example#The easiest way is reuse the code of playground. On the other hand QR code is not necessary, if you review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. There are two examples of how to open debug modes in the Playground App: Set the debug mode via XXXApplication public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; Set the debug mode by scan QR code You review the source code of playground. Debug mode switch control: WXApplication.java Refresh control WXPageActivity.java Known Issues#You can report issues and bugs here. We will reply as soon as possible.","type":"guide"},{"title":"Integrate Devtool to iOS","path":"guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-ios.html","text":"Integrate Devtool to iOS#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your iOS App. Integrate to iOS#Installing Dependencies#There are two choices to install dependencies: No.1 From cocoapods#source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. No.2 From source code# Get source code by GitHub. Copy source folder to your project. Choose options as the picture shows. Integrate#Step 1. Add header file in AppDelegate.m# From cocoapods: #import &lt;TBWXDevtool/WXDevtool.h&gt; ``- From source code #import “WXDevtool.h” #### Step 2. Initialize inspector when the APP launchedYou can see the WXDevtool header file as follows:```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */+ (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end Note: The inspector API must be called before weex is initialized setDebug setDebug is used to control the state of debug mode, when its value is YES, open the debug mode, otherwise closed. (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; open inspect model, remove the @selector (setDebug:) or add [WXDevTool setDebug:NO] eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; Step 3. Auto refresh#Q: Why do we need auto refresh feature? A: As shown in future, when you click the debugger button, Javascript runtime environment will change from the phone (JavaScriptCore) to PC (Chrome V8), then Weex need to re-initialize the Weex environment, re-render the page. Page rendering is required for the developer to add on its own page. Q: What kind of scene need to add refresh feature? Click debugger button Switch remoteDebug Refresh inspect page Q: How to add auto refresh feature? Register events when Weex initialization. [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; Notes: You must cancel this event in the dealloc method. For example: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; For example, First you can destroy the current instance, and then re-create instance: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; You can see the details in this case WXDemoViewController.m","type":"guide"},{"title":"Setup Develop Environment","path":"guide/set-up-env.html","permalink":"https://weex.apache.org/guide/set-up-env.html","text":"Setup Develop Environment#Using dotWe is a good choice, but if you want to develop locally on your own machine, you will need to set up your develop environment. You will need Node.js and the Weex CLI. Install Node.js using nvm (Simple bash script to manage multiple active Node.js versions). Run the following commands in a terminal after installing nvm: $ nvm install 6.10.0$ nvm use 6.10.0 And npm comes with Node.js, with witch you can install the Weex command line tools. NOTE: After upgrading the weex-toolkit to v1.0.8, the npm-shrinkwrap.json npm 5 specification has been added to lock the package dependencies, it is needed to upgrade your npm version to 5 above by command: npm install npm @latest -g if your version is lower than this, please check your npm version before using it. Run the following commands in a terminal: $ npm install -g weex-toolkit$ weex -v You can use ‘weex update @x.x.x’ to update weex-devtool, weex-previewer, weex-builder and weexpack to a specific version.weex update weex-devtool@latest // Here latest means to install the latest version NOTE: If you receive an error like permission error, check out where permission problems occur, please delete the corresponding file and reinstall or run the chmod -R 777 [path] command to authorize. Then you can use the Weex command to verify if the installation is successful: Generate a new Weex project#Use the command line tool to generate a Weex project called “awesome-project”. Run the following command in a terminal: $ weex create awesome-project Then enter the awesome-project folder, you will see a standard project skeleton has been generated. Usage#The weex-toolkit will prompt you whether to automatically run npm install, if not running, manually into the folder and run npm install. In the awesome-project folder, install dependencies with the following command: npm start It will open the preview server automaticly, if you just want to see the web site, you can visite /index.html, like localhost:8081/index.html. NOTE When the port number is occupied, the port number may change, please pay attention to the console output. Folder Structure#| —— configs | —— config.js global config of webpack | —— helper.js helper functions | —— logo.png | —— plugin.js script for compile plugins | —— utils.js tool functions | —— vue-loader.conf.js loader config of weex | —— webpack.common.conf.js webpack configuration for common environment | —— webpack.dev.conf.js webpack configuration for develop environment | —— webpack.prod.conf.js webpack configuration for production environment | —— webpack.test.conf.js webpack configuration for test environment| —— platforms | —— platforms.json platform meta data| —— plugins | —— plugins.json plugin data| —— src | —— entry.js the entry file of whole bundle | —— index.vue vue file source| —— test | —— unit | —— specs test scripts | —— index.js source code and config test environment | —— karma.conf.js configuration for karma| —— web static source| —— .babelrc configuration for babel-loader| —— android.config.json configuration for packing android project| —— ios.config.json configuration for packing ios project| —— npm-shrinkwrap.json npm dependence lock file| —— package.json | —— README.md | —— webpack.config.js entry file of the webpack command For more technical details, please continue to read the next section. And don’t forget to write and preview your codes at dotWe.","type":"guide"},{"title":"Integrate to Your App","path":"guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/guide/integrate-to-your-app.html","text":"Integrate to Your App#Integrate to Android Platform#The following documents assume that you already have a certain Android development experience. Quick Start Five Steps#The keys to intergrating Weex into your Android application are the following five step: 1.Configure Gralde dependency in build.gradledependencies &#123; ... // weex sdk and fastjson compile 'com.taobao.android:weex_sdk:0.5.1@aar' compile 'com.alibaba:fastjson:1.1.46.android' //support library dependencies compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:support-v4:23.1.1' compile 'com.android.support:appcompat-v7:23.1.1'&#125; 2.Add required permissions in your AndroidManifest.xml &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; 3.Init Week SDK When Application Createpublic class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config = new InitConfig.Builder().setImgAdapter(new FrescoImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125;```[Fresco ImageAdapter](https://github.com/apache/incubator-weex/blob/master/android/commons/src/main/java/com/alibaba/weex/commons/adapter/FrescoImageAdapter.java) [Picasso ImageAdapter](https://github.com/apache/incubator-weex/blob/master/android/commons/src/main/java/com/alibaba/weex/commons/adapter/ImageAdapter.java) 4. Create an WXSDKInstance, add IWXRenderListener and activity lifecycle on it. load weex bundle url. when page load success; target view will be send for you on onViewCreated callback, set target view to activity contentView.```javapublic class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = \"WXSample\"; String bundleUrl = \"http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx\"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Run app, start activity, then you will see hello world demo. well done. Hello World Demo Source Tip: Click QRCode Image in Demo Source Page, your will see compiled bundle js. Integrated to iOS#Through the CocoaPods or Carthage integrated Weex iOS SDK to your project.First assume that you have finished installing the iOS development environment and CocoaPods(or Carthage). Step 1: Add Dependencies#Import Weex iOS SDK to your existing project, if not, you can create a new project according to the tutorial).Before proceeding, make sure that the Podfile file is under the project file. If not, create one and open with text editor(if Carthage, please ensure the Cartfile in your project directory). You can choose one of Integration method. using CocoaPods WeexSDK The latest version on cocoaPods can be obtained here . Add the following to the Podfile file: source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.17.0&apos; ## latest Weex SDK recommendedend Open the command line, switch to the directory of the Podfile file, and run the pod install command. If there are no errors, it means that the environment has been configured. using Carthagehere you can get the latest version of WeexSDK.Add github &quot;apache/incubator-weex&quot; to CartfileOpen the command line, switch to the directory of the Cartfile, and run carthage update.Add Carthage build framework to your project Step 2: Initialize the Weex environment#In the AppDelegate.m file to do the initialization operation, usually in the didFinishLaunchingWithOptions method as follows to add. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk environment[WXSDKEngine initSDKEnvironment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level[WXLog setLogLevel: WXLogLevelAll]; Step 3: Render weex Instance#Weex supports both full page rendering and partial rendering. What you need to do is render Weex’s view with the specified URL and add it to its parent container. The parent container is generally a viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very important class that provides a basic method and some callbacks, such as renderWithURL, onCreate, onFailed, etc., can be found in WXSDKInstance.h. Step 4: Destroy Weex Instance#In the dealloc phase of the viewController destroyed Weex instance, can play a role in avoiding memory leaks. - (void)dealloc&#123; [_instance destroyInstance];&#125; Build your own WeexSDK.framework and Import to your project.#The Weex SDK can be compiled from the source code. You can try the latest feature in the new feature or bugfix branch. clone Weex projectyou can use SSH git clone git@github.com:apache/incubator-weex.git or use https git clone https://github.com/apache/incubator-weex.git open WeexSDK.xcodeproj in weex/ios/sdkswitch target just below Build this project or just use the xcode default hot key ⌘ + b Finally you can find Products directory in weex/ios/sdk, WeexSDK.framework was here Add js-framework(which is in the WeexSDK.framework and renamed to native-bundle-main.js) to your main bundle Import the framework you get above and import system framework add -ObjC to your project settings,just like this","type":"guide"},{"title":"Use Vue.js on Weex","path":"guide/use-vue.html","permalink":"https://weex.apache.org/guide/use-vue.html","text":"Runtime-only Build Platform Differences Context DOM Styles Events The Web Renderer Single File Component Compile Targets Use weex-loader Supported Features Global Config Global API Options Lifecycle Hooks Instance Properties Instance Methods Directives Special Attributes Built-In Components Weex integrated the v2 version of Vue.js since WeexSDK v0.10.0 is released at 2016/02/17. Vue (pronounced /vjuː/, like view) is a progressive front-end framework for building user interfaces. Please refer to its official website for more information. If there is no special instructions, the “Vue.js” or “Vue” in this article all refers to the v2 version of Vue.js. Runtime-only Build#If you are familiar with Vue.js, you should know that there are two available builds of Vue.js: the Runtime + Compiler build and the Runtime-only build. The difference between them is whether to include the compiler which is able to compile the template option at runtime. Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, Weex is using the runtime-only build of Vue.js for better performance and less code size. Specifically, the differences are as follows: The template option is not supported when defining a component. Does not support using x-templates. Does not support using Vue.compile. Platform Differences#Vue.js was designed for the Web platform at the beginning. Although it can be based on Weex to develop native applications, there are still many platform differences between Weex and web. The key platform differences are context, DOM, styles and events. Context#Weex is mostly used to write multi-page applications, each page is a native View or Activity on mobile, and has its own context. In particular, the Vue instances are different in each pages, and even the “global” config of Vue (Vue.config.xxx) only affect the single page on Weex. On this basis, some SPA (single-page application) technologies of Vue, such as Vuex and vue-router will also take effect within the single page. More colloquially, the “page” concept is virtual in SPA technologies, but it is real on Weex. However, Vuex and vue-router are standalone libraries, they all have their own concept and usage scenario, you can still use Vuex and vue-router on Weex. DOM#Because there is no DOM (document object model) on Android and iOS, if you are manipulating and generating DOM elements manually, it may have some compatibility issues. It is a good practice to manipulate data and components instead of generated elements when you are using modern front-end frameworks. Some DOM-related features, such as v-html, vm.$el, template option, may not have the same behavior on different platforms. To be more specific, the type of vm.$el property is HTMLElement on the web, but it is not that type on mobile environments. Actually it’s a special data structure defined by Weex document object model. Styles#The style sheet and CSS rules in managed by Weex js framework and native render engines. It would be very difficult and unnecessary to implement the whole CSSOM spec and support all CSS rules. For performance reasons, Weex only support single class selector currently, and only support a subset of CSS Rules. Please refer to common styles and text styles for more details. On Weex, styles are scoped by force for each Vue component. Events#Event bubbling and capturing are not supported in Weex currently, therefore, event modifiers such as .prevent, .capture, .stop, .self are not supported on Weex native components. Moreover, the keyboard event modifiers and system modifier keys, such as .enter, .tab, .ctrl, .shift mostly are meaningless on mobile device, which are also not supported in Weex. The Web Renderer#If you want to render your page on the web, you need to require the weex-vue-render to achieve it. weex-vue-render is a web renderer for Vue DSL, it implemented the built-in components and built-in modules of Weex on the web. Please refer to its repo for more details. Single File Component#Single file component (as known as the *.vue files) of Vue is a special file format with a .vue extension. The template inside will be compiled into the render function at build time. Moreover, there are a good deals of syntax highlight plugins for all kind of editors. It’s a good practice to use single file component syntax in Weex. Compile Targets#Because of the platform difference and to improve the performance on the web, the *.vue file should be compiled in two different ways: For the web platform, you can compile source files in any official way, such as Webpack + vue-loader or Browserify + vueify. For Android and iOS platforms, you should use weex-loader to compile the *.vue files. Use different bundles for different platforms is to make good use of the platform original features and reduce compatibility code at build time. But the source code is still the same, the only difference is the way to compile it. Use weex-loader#weex-loader is a loader for webpack that can transform *.vue file into a plain javascript module for Android and iOS platform. All features and configurations of it are same with vue-loader. One thing should be noted that if the entry option of your Webpack config is a *.vue file, you also need to pass an additional entry parameter. const webpackConfig = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true' /* ... */ use: &#123; loaders: [&#123; // matches the .vue file path which contains the entry parameter test: /\\.vue(\\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;&#125; You don’t need to write those additional parameters if you are using .js file as entry file. It’s a good practice to using javascript file as the entry file of webpack config. &#123; entry: './path/to/entry.js'&#125; Supported Features#Global Config# The Vue “Global” config only affect the single page on Weex, the configuration will not be shared between different Weex pages. Vue Global API Supported Notes Vue.config.silent Yes - Vue.config.optionMergeStrategies Yes - Vue.config.devtools No Only supported on the web. Vue.config.errorHandler Yes - Vue.config.warnHandler Yes - Vue.config.ignoredElements Yes Not Recommended. Vue.config.keyCodes No Useless on the mobile. Vue.config.performance No Same with devtools. Vue.config.productionTip Yes - Global API# Vue Global API Supported Notes Vue.extend Yes - Vue.nextTick Yes - Vue.set Yes - Vue.delete Yes - Vue.directive Yes - Vue.filter Yes - Vue.component Yes - Vue.use Yes - Vue.mixin Yes - Vue.version Yes - Vue.compile No Weex is using the runtime-only build. Options# Vue Option Supported Notes data Yes - props Yes - propsData Yes - computed Yes - methods Yes - watch Yes - el Yes The value of el is meaningless on the mobile. template No Weex is using the runtime-only build. render Yes Not Recommended. renderError Yes - directives Yes - filters Yes - components Yes - parent Yes Not Recommended. mixins Yes - extends Yes - provide/inject Yes Not Recommended. name Yes - delimiters Yes Not Recommended. functional Yes - model Yes - inheritAttrs Yes - comments No - Lifecycle Hooks#Instance lifecycle hooks of Vue components will be emitted at particular stages, refer to the lifecycle diagram of Vue component for more details. Vue Lifecycle Hook Supported Notes beforeCreate Yes - created Yes - beforeMount Yes - mounted Yes Not exactly the same with web. beforeUpdate Yes - updated Yes - activated No Not support &lt;keep-alive&gt; yet. deactivated No Not support &lt;keep-alive&gt; yet. beforeDestroy Yes - destroyed Yes - errorCaptured Yes New in Vue 2.5.0+, Weex SDK 0.18+ Instance Properties# Vue Instance Property Supported Notes vm.$data Yes - vm.$props Yes - vm.$el Yes The value is not HTMLElement on the mobile. vm.$options Yes - vm.$parent Yes - vm.$root Yes - vm.$children Yes - vm.$slots Yes - vm.$scopedSlots Yes - vm.$refs Yes - vm.$isServer Yes Always false. vm.$attrs Yes - vm.$listeners Yes - Instance Methods# Vue Instance Method Supported Notes vm.$watch() Yes - vm.$set() Yes - vm.$delete() Yes - vm.$on() Yes - vm.$once() Yes - vm.$off() Yes - vm.$emit() Yes - vm.$mount() No You don’t need to mount Vue instance manually. vm.$forceUpdate() Yes - vm.$nextTick() Yes - vm.$destroy() Yes - Directives# Vue Directive Supported Notes v-text Yes - v-html No No HTML parser in Weex, and it is not good practice. v-show No Not support display: none; yet. v-if Yes - v-else Yes - v-else-if Yes - v-for Yes - v-on Yes - v-bind Yes - v-model Yes - v-pre Yes - v-cloak No Only support single class selector. v-once Yes - Special Attributes# Vue Special Attribute Supported Notes key Yes - ref Yes - slot Yes - slot-scope Yes New in Vue 2.5.0+, Weex SDK 0.18+ scope Yes Not Recommended. is Yes - Built-In Components# Vue Built-In Component Supported Notes component Yes - transition No The concept of enter and leave maybe different on the mobile, and Weex does not support display: none; yet. transition-group No Same with transition. keep-alive No Native components on the mobile can not be cached at front-end. slot Yes -","type":"guide"},{"title":"Android APIs","path":"references/android-apis.html","permalink":"https://weex.apache.org/references/android-apis.html","text":"Android APIs#WXSDKEngine# Set up various adapters WXSDKEngine.initialize(this, new InitConfig.Builder().setImgAdapter(new ImageAdapter()).setDebugAdapter(new PlayDebugAdapter()).build()); Register the module and component WXSDKEngine.registerComponent(\"richtext\", RichText.class);WXSDKEngine.registerModule(\"event\", WXEventModule.class); Overloading framework WXSDKEngine.reload(this,framework,false); Adapter# IWXImgLoaderAdapter Weex need to implement this interface to download the pictureThe interface is defined as follows: public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality that the quality of the picture variables, take the following values LOW, NORMAL, HIGH, ORIGINAL picture quality in turn higher. The default is LOW. WXImageStrategy is an extension class that indicates whether the image can be cut (isClipping) sharpening (isSharpen) placeholder (placeHolder) and so on. IWXHttpAdapter Weex custom WXRequest and OnHttpListener, Native reload interface can be obtained from the Request URL, Header and other parameters, the network request can be completed through OnHttpListener callback notification. Weex provides the default network request: DefaultWXHttpAdapter, using HttpURLConnection for network requests. The interface is defined as follows: public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest defines the parameters related to the network request, the request method, the request body, and the timeout time. Weex default timeout is 3000. OnHttpListener defines the corresponding method after the network request ends. Defined as follows: interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response); &#125; IWXUserTrackAdapter Weex related performance data (first screen loading time, JS-Native communication time, dom update time, etc.) and other general information (JSLib file size, Weex SDK version number, etc.).Interface definition: public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native implementation interface can be obtained through WXPerformance and params corresponding information. Native interacts with JavaScript#Custom events#Used for a custom control for event notifications, such as custom click events, response drop events, and so on. WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：The event occurred for the control ID。 type: Custom events, Weex defaults to a custom event starting with onXxxxx. OnPullDown (drop-down event) data: Need to reveal the parameters, such as the current control of the size, coordinates and other information。 domChanges：Update ref for the control’s Attribute and Style Event callback#Used for Module callback, for example, after the completion of positioning Module need to notify JS. Use as follows: public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //Get the code for the location information ..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //notify once callback.invoke(data); //Continuous connection callback.invokeAndKeepAlive(data); //Invoke method and invokeAndKeepAlive two methods of choice &#125;&#125; OnWXScrollListener#Weex gets the scroll event You can register registerOnWXScrollListener via WXSDKInstanceThe interface is defined as follows: public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; IActivityNavBarSetter#Weex provides WXNavigatorModule for navigation control, and the corresponding method can be customized by setting the IActivityNavBarSetter interface. Instructions: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); Other Introduction#setSize#You can use the mWXSDKInstance.setSize() method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onException method in interface IWXRenderListener, and if it is an active demoulding errCode is a character that is divided by “|”. “|” The preceding character is 1 for active demotion, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"BroadcastChannel","path":"references/broadcast-channel.html","permalink":"https://weex.apache.org/references/broadcast-channel.html","text":"API Communication Procedure Usage Example Notice The BroadcastChannel is available since v0.9+. As mentioned in JS Runtime Context, Weex is using different context for each page, even global variables are isolated, but BroadcastChannel is a way to achieve cross-page communication. API# BroadcastChannel is part of W3C specifications, as well as the MessageEvent. The constructor of BroadcastChannel only take one single parameter which is the channel name. const jb = new BroadcastChannel('007') The type declaration of the BroadcastChannel is: declare interface BroadcastChannel = &#123; name: string, postMessage: (message: any) =&gt; void; onmessage: (event: MessageEvent) =&gt; void; close: () =&gt; void;&#125; name: The channel name, it’s the indicator when broadcast messages. postMessage: Sends the given message to other BroadcastChannel objects set up for this channel. onmessage: The event handler. An event will be triggered when the instance received a message. close: Closes the BroadcastChannel object, opening it up to garbage collection. The type declaration of the MessageEvent is: declare interface MessageEvent = &#123; type: string, // \"message\" data: any&#125; Communication Procedure# Just like using radio, each client joins a specific channel by creating a BroadcastChannel object with the same channel name. Then implement the onmessage event handler to listen on the underlying channel. Call the postMessage() method on the BroadcastChannel object will broadcast a message to every subscriber of the channel. Indeed, it’s a full-duplex (bi-directional) communication between all subscriber of the particular channel, each of them is able to receive any message that has been posted to it. Even the sender of the message can receive the message event itself. Communications between different channels will not affect each other. To leave a channel, it is required to call the close() method on the BroadcastChannel object. This method only closed itself, and does not affect other subscribers. When a Weex page is destroyed, all subscribers in it will be closed at destroyInstance. If all subscribers of a channel are closed, the underlying channel would be destroyed and allows garbage collection to happen. Usage Example#In page A: const Steve = new BroadcastChannel('Avengers')Steve.postMessage('Assemble!') In page B: const Hulk = new BroadcastChannel('Avengers') In page C: const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // Assemble! Stack.postMessage('I am Tony and I am leaving now.')&#125; The page A, B and C are all create a BroadcastChannel object which is listening on the &#39;Avengers&#39; channel. They can use it to communicate with each other. When Steve post the message &#39;Assemble!&#39;, Stack will receive a message event whose data equals the &#39;Assemble!&#39;, and then send another message back. But Hulk will not receive the message because he does not implement the onmessage method, so he is not a subscriber actually. Notice# The message object is not deep cloned. (This feature could be changed.) In page A: const a = new BroadcastChannel('app')const list = ['A', 'B']a.postMessage(list) In page B: const b = new BroadcastChannel('app')b.onmessage = function (event) &#123; // the event.data is a reference of list in page A event.data.push('C')&#125; In this case, the event.data in page B is a reference of list in page A. When pushing a new item &#39;C&#39;, it will also affect the list object in page A. Compared to the deep clone, this behavior improves efficiency and reduces memory cost. However, developers are not recommended caching or modifying the event object after received it.","type":"references"},{"title":"iOS APIs","path":"references/ios-apis.html","permalink":"https://weex.apache.org/references/ios-apis.html","text":"iOS APIs#Handler(like Android Adapter)# WXImgLoaderDefaultImpl Image load handler. Weex need to implement this interface to download the picture. The interface is defined as follows: @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native interacts with JavaScript# Custom events Used for a custom control for event notifications, such as custom click events, response drop events, and so on. This is a method in the component base class that can be used directly. /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName * @param params * @param domChanges **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges Event callback Used for Module callback. There are two types of callback: WXModuleCallback: For performance reasons, the callback can only callback js once, and then will be released. WXModuleKeepAliveCallback: This callback can be set to multiple callbacks, multiple callbacks of the scene such as continually listen scrolls event and return to js. @implementation WXEchoModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);&#125; Set size of the Weex container#You can use the setFrame(CGRect) method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onFailed method in interface WXSDKInstance, and if it is an active demoulding error domain is TemplateErrorType, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"JS Service","path":"references/js-service.html","permalink":"https://weex.apache.org/references/js-service.html","text":"JS Service#v0.9.5+ JS service and Weex instance are parallel in js runtime. Weex instance lifecycle will invoke JS service lifecycle. Currently provide create, refresh, destroy of lifecycle. !!!Important: JS Service is very powerful. Please be careful to use. Register JS Service#iOS#[WeexSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;!-- Should be loaded after then jsfm --&gt;&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; Write a JS Service#// options: native inject options// options.serviceName is native options nameservice.register(options.serviceName, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: fucntion() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"Weex Variable","path":"references/weex-variable.html","permalink":"https://weex.apache.org/references/weex-variable.html","text":"Properties and Methods weex.config Weex Environment Object weex.document weex.requireModule Use Native Module weex.supports Examples Each page of Weex contains a weex variable in the js runtime context. It can be assessed directly just like a global object, but it’s readonly and separated from different pages. NOTE: The weex variable only exposed in the Vue framework. It’s not available in Rax framework yet. Properties and Methods#The type declaration of the Weex variable is: declare type Weex = &#123; config: WeexConfigAPI; document: WeexDocument; requireModule: (name: string) =&gt; Object | void; supports: (condition: string) =&gt; boolean | void;&#125; weex.config#The weex.config contains all the environment information of current page. declare type WeexConfigAPI = &#123; bundleUrl: string; bundleType?: string; env: WeexEnvironment;&#125; bundleUrl: The URL of the js bundle in current page. bundleType: v0.17+ The type of the js bundle, it indicates which framework is using for current js bundle, could be &quot;Vue&quot; or &quot;Rax&quot;. env: Weex environment object. Weex Environment Object#Sometimes, you still need to write some platform specific codes for compatibility or enhancement. Weex provides weex.config.env and a global object WXEnvironment (they are strictly equal) to get the information of current runtime environment. weex.config.env === WXEnvironment Properties in Weex environment object: Property Type Description platform String Current running platform, could be “Android”, “iOS” or “Web”. weexVersion String The version of Weex SDK. appName String Mobile app name or browser name. appVersion String The version of current app. osName String The OS name, could be “Android” or “iOS”. osVersion String The version of current OS. deviceModel String Mobile phone device model. (native only) deviceWidth Number Screen resolution width. deviceHeight Number Screen resolution height. This example prints all properties in the Weex environment object. weex.document#The weex.document is the document object of current page, it can be used to create or manipulate the Elements in DOM tree. It’s part of Weex DOM API specification which is NOT the same with the document object in the W3C DOM API. However, it’s not a good practice to manipulate DOM directly when using modern front-end frameworks, such as Vue and Rax. Especially, there is no actually DOM in Weex, it was simulated on the native (Android or iOS). This API is mainly used inside of the Vue and Rax framework to convert the virtual-dom into render directives and send them to native render engines of Weex. Not recommended for using it when developing pages. weex.requireModule#For those features which does not rely on the UI, Weex wraps them into modules. It is a way to access native capabilities in javascript. Except for the built-in modules, it’s quite easy to integrate the existing native modules to Weex platform. After that, you can use weex.requireModule to require both customized and built-in modules. weex.requireModule(name: string): Object | void; Parameter: A case-sensitive module name. Return Value: If the module is registered, return a Proxy or plain object if the context doesn’t support Proxy. You can use it to call the registered methods in the module. If the module is unregistered, return undefined. Use Native Module#You can require a native module and use its APIs just like normal javascript functions. Here is a simple example of using the modal module: &lt;template&gt; &lt;div&gt;&lt;text&gt;Toast&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.supports# This API only available in v0.15+. As you may know, components and modules are extendable and configurable in Weex. So it could be various in different apps or running context. You can use weex.supports to detect whether a feature is supported in the current environment at runtime. weex.supports(condition: string): boolean | void; Parameter: A formatted condition string: @{type}/{name}. The type must be &quot;component&quot; or &quot;module&quot;. The name could be a tag name, module name or the method name in specific module. Return Value: If the feature is supported, return true. If the feature is unsupported, return false. If not sure about whether this feature is supported, return null. Examples#Detects whether the specific component is supported: weex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false Detects whether the specific module is supported: weex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false Detects whether the method in specific module is supported: weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false Invalid input or unknown features: weex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null","type":"references"},{"title":"Helpers","path":"tools/helpers.html","permalink":"https://weex.apache.org/tools/helpers.html","text":"Weex Language Support Plugin#Weex Language Support is a official tools to code highlight, automatic completion，lint and other functions in IDEA, WebStorm or the others IDEs. Supported IDEs#You can install and use this plugin on the following IDEs on any operating system:IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider Install#Just searching the Weex Language Support in plugin repo to install, next you need restart IDE to enable it. Configurations#Open Preferences -&gt; Other Settings -&gt; Weex language support to configuration plugin Target Weex Version: Config the version of Weex that your current project in use, default is LATEST, it means always using the latest version Vue Support: Config whether to support Vue, you need to restart IDE after turning on or off the set to take effect Custom Rules: Import the custom Weex DSL rules, The format of the custom rules will be listed later Global Weex Components: Sets the location of the module that is applied in the project, in particular, the node_modules directory in current project and npm root will be automatically included, you do not need to add them here Format of Custom DSL Rules#Custom rules are included in a json file, the root node of the json file is an array, each element in the array corresponds to a label in the DSL.Let’s take the example of the loading&gt; tag:&#123; \"tag\": \"loading\", //tag name, not null \"attrs\": [ //attributes of tag, can be null &#123; \"name\": \"display\", //attribute name, not null \"valuePattern\": null, //pattern expression to check the attribute value, can be null \"valueEnum\": [ //attribute value enumeration, can be null \"show\", \"hide\" ], \"valueType\": \"var\", //type of attribute value, must be var or function \"since\": 0, //which version the attribute is added to sdk, such as 0.11 \"weexOnly\": false //whether the attribute is available only in 1.0 syntax, default is false &#125; ], \"events\": [ //events list, can be null &#123; \"name\": \"loading\", //event name, not null \"since\": 0 //which version the event is added to sdk &#125; ], \"parents\": [ //The tag is allowed to be a child of which tags, null means no restrictions \"list\", \"scroller\" ], \"childes\": [ //which tags are allowed as their own child tags, null means no restrictions \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //document link &#125; Contribution#Please commiting Issues and Pull Requests into the weex-language-support project","type":"tools"},{"title":"Use weex-toolkit","path":"tools/toolkit.html","permalink":"https://weex.apache.org/tools/toolkit.html","text":"weex-toolkit#weex-toolkit is an official command line tool to help developers to create, debug and build their Weex project. Install#$ npm install -g weex-toolkit You can use the weex -v command to confirm that the installation is successful. If you have never installed node.js, you should go node.js.org to download and install it. NOTE: The node version needs to be upper 6.0. You can try n to manage your node versions. If you meet some errors when installing, please go weex-toolkit issues or weex-toolkit faq to find some solution or have a discuss with us. Commands#create#$ weex create awesome-project Creates a new weex project. After command running, you can find awesome-project directory and there are some Weex templates in it.There are some useful npm scripts you will use in the future: build: build the source code and generate the JS bundle dev: run webpack watch configuration serve: start a hot-reload web server You need to run npm i before running npm start to install project dependencies，after that, the development page will open in the browser automatically preview#weex-toolkit supports previewing your Weex file(.vue) in a watch mode. You only need specify your file path. $ weex preview src/foo.vue The browser automatically opens the preview page and you can see the layout and effects of your weex page. If you have a Playground app in your mobile devices, you can scan the QR code at the opened page. Try the command below, you’ll preview the whole directory files. $ weex preview src --entry src/foo.vue You need to specify the folder path to preview and the entry file (passed in via --entry). compile#Use weex compile o compile a single weex file or a weex file in an entire folder. $ weex compile [source] [dist] [options] options# Option Description -w, --watch watch we file changes auto build them and refresh debugger page! [default true] -d,--devtool [devtool] set webpack devtool mode -e,--ext [ext] set enabled extname for compiler default is vue -m, --min set jsbundle uglify or not. [default false] You can use like this: $ weex compile src dest --devtool source-map -m platform#Use weex platform [add|remove] [ios|android] to add or remove ios / android project templates. $ weex platform add ios$ weex platform remove ios Use weex platform list to show what platforms your application supported. run#You can use weex-toolkit to run project on android/ios/web. $ weex run ios$ weex run android$ weex run web debug# Weex devtools is a custom devtools for Weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page, both android and iOS platform are supported. So you can use weex-devtools feature by weex-toolkit. usage#weex debug [we_file|bundles_dir] [options] Option Description -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer or loader] -w, --watch watch we file changes auto build them and refresh debugger page [default true] --ip [ip] set the host ip of debugger server --loglevel [loglevel] set log level --min set jsbundle uglify or not. [default false] --debug start with node-inspect default port is 9331 Features#Connect devices#$ weex debug This command will start debug server and launch a chrome opening DeviceList page.this page will display a QR code, you can use Playground scan it for starting debug or integrate Weex devtools into your application. debug with .vue file#$ weex debug your_weex.vue This command will compile your_weex.vue to your_weex.js and start the debug server as upon command.your_weex.js will be deployed on the server and displayed on the debug page, using another QR code for debugging your_weex.js file. start debugger with a directory of vue files#$weex debug your/vue/path -e index.vue This command will compile each of the files in your/vue/path and deploy them on the bundled server with the new file mapped to the path http://localhost:port/weex/ with the -e designated path as the entrance to the page. Inspector# Inspector can be used to show your Element \\ Network \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. Element# NetWork# show the total time and latency# show the header and response# Console# Resource# Debugger# Breakpoint and CallStack# Integrate devtool# Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. iOS See the doc Weex devtools (iOS), it will lead you to config and use it step by step.","type":"tools"},{"title":"Common Events","path":"wiki/common-events.html","permalink":"https://weex.apache.org/wiki/common-events.html","text":"Common Events#Weex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Bellow are the common event attributes that can be added to weex components to define event actions. Click event#The onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Longpress event#If a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Appear event#If a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object# type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Disappear event#If a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object# type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Page event#Weex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object# type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"Color name","path":"wiki/color-names.html","permalink":"https://weex.apache.org/wiki/color-names.html","text":"List of the names of colors#Basic color keywords:# Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords:# Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"Event Bubble","path":"wiki/event-bubble.html","permalink":"https://weex.apache.org/wiki/event-bubble.html","text":"Event Bubble v0.13+#Weex 2.0 implements the W3C standard event bubbling mechanism. Usage#&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the elements, you can see the event spread up, followed by the trigger. Notice#One thing should be noticed: For compatibility with previous versions, Weex does not turn on event bubbling by default. You need to add bubble = &quot;true&quot; on the root element’s properties to turn on the bubbling mechanism. Otherwise, the event will not be propagated upwards, keeping the same effect as the previous version. stopPropagation#In the event handler function, you can use the e.stopPropagation() method to prevent the event from escalating. Note that e.stopPropagation() differs from bubble = &quot;true&quot;, which affects only the current elements and the propagation of parent elements, without affecting the propagation of child elements; the latter is a switching mechanism that is added for compatibility, Will be a global shutdown or open the bubble mechanism, the two can co-exist, as follows: &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the element, you can see the event up to the parent element is terminated, no longer continue to spread to the root element.","type":"wiki"},{"title":"Common Style","path":"wiki/common-styles.html","permalink":"https://weex.apache.org/wiki/common-styles.html","text":"Common Style#All of weex tags share some common style rules Box Model# Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0 border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 Notes#Weex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt;in iOS. This only happens to iOS, it works fine on Android. Although overflow:hidden is default on android, a view will not clip its children according to border-radius unless all the following condtions met. This only happens on Android, it works fine on iOS. The view type is div, a, cell, refresh or loading. OS version is Android 4.3 or higher. OS version is not Andorid 7.0 A view does not have background-image property nor OS version is Android 5.0 or higher. Example#&lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex container#Flexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item# flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examples#a list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Position#we can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples#&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; transform#The CSS transform property lets you modify the coordinate space of the CSS visual formatting model. Using it, elements can be translated, rotated and scaled. Currently supported format: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) rotateX( ) v0.14+ rotateY( ) v0.14+ perspective( ), supported for Android 4.1 and above. v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.17.0+#Now you can use the transition attribute in CSS to enhance the interactivity and visual experience of your application. The transition includes the layout animation, that is, LayoutAnimation, which now changes the layout and uses the fluent animation of the transition. Transition allows the CSS attribute values to transition smoothly over a certain time interval. Property# transition-property:Allows the name of the transitional animation to set the value of the different styles transition effect, the default value is empty, that does not perform any transition, the following table lists all the legitimate parameters of the property: Property Description width The transition is performed when the width of the component is involved in the animation height The transition is performed when the height of the component is involved in the animation top The transition is performed when the top of the component is involved in the animation bottom The transition is performed when the bottom of the component is involved in the animation left The transition is performed when the left of the component is involved in the animation right The transition is performed when the right of the component is involved in the animation backgroundColor The transition is performed when the backgroundColor of the component is involved in the animation opacity The transition is performed when the opacity of the component is involved in the animation transform The transition is performed when the transform of the component is involved in the animation transition-duration:Specifies the duration of the transition transition (in milliseconds). The default value is 0, indicating that there is no animation. transition-delay:Specifies the time interval (in milliseconds or seconds) between the request transition transition and the transition transition. The default value is 0, indicating that there is no delay, and the transition transition is performed immediately after the request. transition-timing-function:Describes the velocity curve of the transition transition, which is used to make the transition transition smoother. The default is ease. The following table lists all the valid attributes: Property Description ease The transition gradually slow down the transition effect ease-in The transition starts slowly and then becomes faster for the transition effect ease-out The transition starts quickly and then slows the transition effect ease-in-out The transition starts slowly, then goes fast and then slowly ends the transition effect linear The transition changes at constant speed cubic-bezier(x1, y1, x2, y2) Using the custom transition in the third-order Bessel function, the parameter values of the function must be between 0 and 1. For more information on three times Bessel, see cubic-bezier and Bézier curve. Example#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; Pseudo class v0.9.5+#Weex support four pseudo-classes: active, focus, disabled, enabled All components support active, but only the input component and the textarea component support focus, enabled, diabled. Rule# the high priority override low priority when rules take effect at the same time such as: “input:active:enabled” will override “input:active” the interconnection rule as follow Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; Try it linear-gradient v0.10+#Weex support linear-gradient background, You can see W3C description of the gradient. Supported components#All components in Weex support gradients Usage#You can use linear gradient by background-image property. background-image: linear-gradient(to top,#a80077,#66ff00); radial-gradient is not currently supported, do not use it. Weex currently supports two color gradients. The direction of the gradient is as follows: to rightFrom left to right to leftFrom right to left to bottomFrom top to bottom to topFrom bottom to top to bottom rightFrom the upper left corner to the lower right corner to top leftFrom the lower right corner to the upper left corner Note# background-image and background-color are set at the same time, background-image precedes background-color. Do not use shorthand property such as background. Example#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; box-shadow v0.11+#Weex supports box-shadow in iOS： inset,offset-x,offset-y, blur-radius,color Note# box-shadow takes effect in iOS Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; Other Common Style# opacity background-color Type of Style Value# length type number type color type (The list of color keywords.) enumerated type Simple Step#These up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"wiki"},{"title":"CSS Units","path":"wiki/css-units.html","permalink":"https://weex.apache.org/wiki/css-units.html","text":"CSS Units#Work in progresss.","type":"wiki"},{"title":"Design Principles","path":"wiki/design-principles.html","permalink":"https://weex.apache.org/wiki/design-principles.html","text":"","type":"wiki"},{"title":"Gesture","path":"wiki/gestures.html","permalink":"https://weex.apache.org/wiki/gestures.html","text":"Gesture# Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Just set on attributes on a node to listen to gesture. Type#For now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. shouldStopPropagation every touch event will be fired, you can control touch event whether should be bubbled by return true(should bubble) or false(touch event consumed by this view, will not be bubbled). this can be used to handle touch confliction between views. (since v0.18+) Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Horizontal/Vertical Pan v0.10+ . Mainly used for cell swipe gestures before conflict resolving system is completed. start/move/end state of the gesture will be passed by state property. Note: These gestures are in conflict with click event on Android currently. horizontalpan verticalpan Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. LongPress is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. Properties#The following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedTouches#changedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. Constrain#Currently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting.","type":"wiki"},{"title":"Platform Differences with Web","path":"wiki/platform-difference.html","permalink":"https://weex.apache.org/wiki/platform-difference.html","text":"Platform Differences with Web#Work in progresss.","type":"wiki"},{"title":"Text Styles","path":"wiki/text-styles.html","permalink":"https://weex.apache.org/wiki/text-styles.html","text":"Text alike components share some common style rules. The text alike components currently includes text and input. Properties# color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weightv0.9+: values: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal is equal to 400, bold equel to 700 default value: normal apply to: &lt;text&gt;, &lt;input&gt; ios support showing 9 kind of font-weight. android support showing 2 kind of font-weight:400,700, other value will map to 400 or 700 Some standard values like lighter, bolder, number unit are not supported. The effect not apply to all elements, just &lt;text&gt; and &lt;input&gt;. In another way, it’s not inherited. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value# length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"wiki"},{"title":"HTML5 扩展","path":"cn/guide/extend-web-render.html","permalink":"https://weex.apache.org/cn/guide/extend-web-render.html","text":"横向扩展 weex 组件#Vue.js 本身就是一个独立的前端框架，在浏览器中完全能够不基于 Weex 容器渲染。因此，针对 Weex 平台扩展 Vue.js 的 Web 端组件，和直接使用 Vue.js 开发一个 Web 组件是一样的。具体的组件编写方法可以参考其官方文档：组件 ，另外建议使用 .vue 格式的文件编写组件，使用方法参考：单文件组件。 扩展 Web 端 renderer 的内置组件#Weex 本身提供了很多内置组件和模块，也具备横向扩展的能力，允许开发者自行扩展和定制。需要注意的是，Weex 是一个跨平台的解决方案，扩展其内置组件或模块，需要在三端（Android、iOS、Web）中都有相应的实现。 Weex 将内核切换成 Vue 2.x 之后，在 Web 端扩展 Vue 组件将变得更加容易。 目前我们提供了 weex-vue-render 作为 Vue 2.x Web 端的渲染器。首先引入该库到你的项目里，然后你就可以使用 weex.registerComponent 来进行内置组件扩展了，也可以使用 Vue.component，两者基本上是一致的。 扩展内置组件示例#以扩展 &lt;sidebar&gt; 为例，首先应该编写组件自身的逻辑： &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; 然后在使用之前，全局注册 &lt;sidebar&gt; 组件： import Vue from 'vue'import weex from 'weex-vue-render'import Sidebar from './path/to/sidebar.vue'weex.init(Vue)// 全局注册 sidebar 组件weex.registerComponent('sidebar', Sidebar)// 或者使用 Vue.componentVue.component('sidebar', Sidebar) 在扩展 Weex 组件时，如果只使用了 Weex 提供的内置组件，并且使用的都是 Weex 支持的样式，那么就和普通的自定义组件无异，不需要 Native 端再有相应的实现。 如果你定制组件时不得不用到目前 Weex 不支持的标签和样式，在这种情况下才是真正的“扩展”了 Weex 的组件，你还需要在 Android 和 iOS 中有相应的实现，不然会导致渲染异常。 扩展 Web 模块#除了通用组件以外，Weex 还有提供了通用的模块，可以方便的调用原生 API。通常来说，注册 Weex 模块要求三端都得有相应的实现，否则会影响其正常的使用。 注册模块#如果你引入了 weex-vue-render 这个库，那么在全局能获取到 weex 这个变量，其中提供了 registerModule 方法可以注册模块。 API 格式# registerModule name: {String} 必选，模块名称。 define: {Object} 必选，模块的定义。 meta: {Object} 可选，如果你需要将非 iterable 的属性或方法注册到模块对象里，你才需要用到这个参数，将 { registerType: &#39;assignment&#39; } 作为 meta 参数传入即可。 注册模块示例#下边的代码注册了一个名为 guide 的模块： weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) 使用模块#在 weex 上提供了 require 方法用于获取已注册的模块，直接传递模块名即可： // 获取模块const guide = weex.requireModule('guide')// 可以直接调用模块中的方法guide.greeting()guide.farewell() 上述模块使用方法在 Native 环境中依然有效，只不过模块中的方法是由 Native 提供的。","type":"guide"},{"title":"Android 扩展","path":"cn/guide/extend-android.html","permalink":"https://weex.apache.org/cn/guide/extend-android.html","text":"Android 扩展#Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展# Module 扩展必须继承 WXModule 类。 扩展方法必须加上@JSMethod (uiThread = false or true) 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule&#123; //run ui thread @JSMethod (uiThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; //run JS thread @JSMethod (uiThread = false) public void fireEventSyncCall()&#123; //implement your module logic here &#125;&#125; Register the module WXSDKEngine.registerModule(\"MyModule\", WXEventModule.class); JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;testMyModule&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('myModule').printLog(\"I am a weex Module\"); &#125; &#125; &#125;&lt;/script&gt; Component 扩展# Component 扩展类必须集成 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richtext&quot;,RichText.class); 示例如下: public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; 注册你的组件： WXSDKEngine.registerComponent(\"MyView\",MyViewComponent.class); JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; 组件方法支持#从WeexSDK 0.9.5开始，你可以定义组件方法 在组件中如下声明一个组件方法 @JSMethodpublic void focus()&#123; //method implementation&#125; 注册组之后，你可以在weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39; Adapter扩展#图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; SDK混淆规则#若要在APP中使用混淆，请在相应的配置文件中添加如下规则： -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;-keep class com.taobao.weex.bridge.**&#123;*;&#125;-keep class com.taobao.weex.dom.**&#123;*;&#125;-keep class com.taobao.weex.adapter.**&#123;*;&#125;-keep class com.taobao.weex.common.**&#123;*;&#125;-keep class * implements com.taobao.weex.IWXObject&#123;*;&#125;-keep class com.taobao.weex.ui.**&#123;*;&#125;-keep class com.taobao.weex.ui.component.**&#123;*;&#125;-keep class com.taobao.weex.utils.**&#123; public &lt;fields&gt;; public &lt;methods&gt;; &#125;-keep class com.taobao.weex.view.**&#123;*;&#125;-keep class com.taobao.weex.module.**&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep class * implements com.taobao.weex.ui.IExternalComponentGetter&#123;*;&#125;","type":"guide"},{"title":"拓展 JS framework","path":"cn/guide/extend-js-framework.html","permalink":"https://weex.apache.org/cn/guide/extend-js-framework.html","text":"定制自己的 JS Framework#这部分扩展能力还在讨论尝试中，可能随时会有调整，请留意。 Weex 希望能够尊重尽可能多的开发者的使用习惯，所以除了 Weex 官方支持的 Vue 2.0 之外，开发者还可以定制并横向扩展自己的或自己喜欢的 JS Framework。完整一套 JS Framework 的定制和扩展需要以下几个步骤： 首先你要有一套完整的 JS Framework。 了解 Weex 的 JS 引擎的特性支持情况。 适配 Weex 的 native DOM APIs。 适配 Weex 的初始化入口和多实例管理机制。 在 Weex JS runtime 的 framework 配置中加入自己的 JS Framework 然后打包。 基于该 JS Framework 撰写 JS bundle，并加入特定的前缀注释，以便 Weex JS runtime 能够正确识别。 Weex JS 引擎的特性支持情况# 在 iOS 下，Weex 使用的是系统自带的 JavaScriptCore，所以 ES 支持情况取决于操作系统的版本。目前保守判断，ES5 的特性市面上主流的 iOS 设备都是可以完美支持的，但是 ES6+ 的特性存在一定的碎片化。 在 Android 下，Weex 使用的是 UC 提供的 v8 内核，出于体积、性能和稳定性的考虑，我们使用的并不是最新版本的 v8 内核，同样的保守判断，ES5 特性能够全部支持，包括严格模式、Object.freeze 等。 Weex JS 引擎不支持 HTML DOM APIs 和 HTML5 JS APIs，这包括 document, setTimeout 等。 在此基础上，我们加入了 Promise 的 polyfill，以及 console 的 polyfill。 额外的，为了尽可能的确保 JS 引擎的长效内存管理，我们对一个通用的全局对象进行了 Object.freeze() 冻结操作，这包括： Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype 适配 Weex 的初始化入口和多实例管理机制#开发者提供的 JS Framework 最终需要包装成一个 CommonJS 包，并且这个包需要对外暴露以下方法： 框架初始化# init(config) config Document Element Comment TaskSender CallbackManager 该方法会把 Weex 提供的 Native DOM 类和两个辅助类放到 config 参数中，并允许框架本身完成初始化。 小提示：同时，框架作者也能够通过在框架初始化时传入不同的 config 来进行框架的测试或环境模拟。 参数格式介绍# TaskSender: wip… CallbackManager: wip… 注册可用的 native 组件和模块# registerComponents(components) registerModules(modules) 这两个方法会在框架初始化之后立刻调用，这样框架就能够知道当前的客户端支持哪些组件和模块，在一些特殊逻辑或必要的情况下，有机会为框架本身提供参考信息。 参数格式介绍# components: Array: 描述组件的数组，每一项包括： type: string: 组件名称，比如 div。 methods: string[]: 可选项，该组件支持的方法名称列表，这些方法可以遵循 Weex 的 native DOM APIs 的组件方法调用方式。 modules: Object: 描述一系列模块的散列表，每一项的 key 是模块名，每一项的值是一个数组，数组里的每一项描述了一个该模块中的一个方法，该方法的信息包括： name: string: 方法名 args: string[]: 参数个数和类型描述 例如： registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) 多实例生命周期管理# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) 每个 Weex 页面都有被创建、被销毁两个必经阶段，同时在 Weex 页面运行过程中，native 有机会主动向 Weex 页面发送消息，不同的框架可以根据自己框架的设计对这样的消息有自己的理解和设计实现。 参数格式介绍# instanceId: string: 该 Weex 页面的唯一 id，由 native 产生。 code: string: 该 Weex 页面的 JS bundle 的代码，通过 native 传入。 config: Object?: 该 Weex 页面的配置信息，比如代表该 bundle 地址的 bundleUrl，由 native 配置产生，和 JS bundle 本身的内容无关。 data: Object?: Native 有机会在创建一个 Weex 页面的时候，传入一份外部数据，JS 框架也有机会接此机会为相同的 JS bundle 配合不同的 data 生成不同的页面内容。 env: Object?: 当前 Weex 页面的相关环境信息，各字段的含义： info: Object: 框架 info 信息，详见之后的 “JS Bundle 格式要求”。 config: Object: 等同该方法的第三个参数 config。 callbacks: CallbackManager: 该 Weex 页面唯一的 CallbackManager 实例。 created: number: 该 Weex 页面的创建时间毫秒数。 framework: string: 该 Weex 页面基于的框架名，等同于 info.framework。 Native 通信# receiveTasks(instanceId, tasks) Native 除了通过 refreshInstance 方法向 JS 框架层发送消息之外，更多的会通过 receiveTasks 发送用户事件或方法回调给 JS 框架。 比如用户点击了一个按钮，native 就会发送一个 fireEvent 类型的任务给 JS 框架，然后 JS 框架再处理相应的事件逻辑。这部分工作机制和 native DOM 接口中的 addEvent 的设计有关。 再比如用户发起了一个 fetch 网络请求，当请求在 native 端完成时，会以一个 callback 类型的任务发给 JS 框架。由于 native 无法传递 JavaScript 中的 function，所以实际上知会发送一个 callbackId 给 JS 框架。这部分工作机制和之前出现过的 CallbackManager 的设计有关。 辅助方法# getRoot(instanceId): JSON 该方法可以返回文档主体结点的完整 JSON 描述，开发者可以以此查看到完整的 native DOM 树，具体返回值的格式和 native DOM 接口中的 toJSON() 方法返回值格式一致。此功能多用作开发者工具扩展。 在 WeexSDK 中配置 JS Framework#准备好你的 JS Framework 代码#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; 注册一个 JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; 然后打包 JS runtime，集成到 WeexSDK 中。 JS Bundle 格式要求#框架 info 你需要保障基于该 JS Framework 的 JS Bundle 在文件开头带有如下格式的注释，我们称其为框架 info： // &#123; \"framework\": \"Vue\" &#125;... 这样 Weex JS 引擎就会识别出这个 JS bundle 需要用 Vue 框架来解析。并分发给 Vue 框架处理。同理，Weex 支持同时多种框架在一个移动应用中共存并各自解析基于不同框架的 JS bundle。","type":"guide"},{"title":"前端框架","path":"cn/guide/front-end-frameworks.html","permalink":"https://weex.apache.org/cn/guide/front-end-frameworks.html","text":"Weex 中的前端框架 Vue.js Rax Weex 中的前端框架# 前端技术看起来很繁荣，测试、打包、调试等工具都比较丰富，开发效率比原生开发要高很多。在大型项目中使用前端框架也是一个管理应用好方法，这样更方便于长期维护。 然而，Weex并不是一个前端框架。实际上，前端框架仅仅是 Weex 的语法层或称之为 DSL (Domain-specific Language)，它们与原生渲染引擎是分离的。换句话说，Weex 并不依赖于特定的前端框架，随着前端技术的发展，Weex 也可以集成更多广泛使用的前端框架。 目前 Weex 主要支持 Vue.js 和 Rax 作为其内置的前端框架。这些框架已经集成到了 Weex SDK，你不需要在额外引入。 学习一些 Vue 和 Rax 的基础知识，对使用 Weex 非常有帮助。 Vue.js#Weex 从 v0.10.0（发布于 2016/02/17）这个版本开始，就集成了 v2 版本的 Vue.js。Vue.js 是一套用于构建用户界面的渐进式框架，详情请参阅其官方网站。 关于在 Weex 中使用 Vue 的技巧请参阅：《使用 Vue》。 Rax#Rax 是一个兼容 React 接口的前端框架，请参考 Rax 的官方网站 来获得更多信息。","type":"guide"},{"title":"iOS 扩展","path":"cn/guide/extend-ios.html","permalink":"https://weex.apache.org/cn/guide/extend-ios.html","text":"注意#Weex 所有暴露给 JS 的内置 module 或 component API 都是安全和可控的， 它们不会去访问系统的私有 API ，也不会去做任何 runtime 上的 hack 更不会去改变应用原有的功能定位。 如果需要扩展自定义的 module 或者 component ，一定注意不要将 OC 的 runtime 暴露给 JS ， 不要将一些诸如 dlopen()， dlsym()， respondsToSelector:，performSelector:，method_exchangeImplementations() 的动态和不可控的方法暴露给JS， 也不要将系统的私有API暴露给JS Module 扩展#swift 扩展 module Weex SDK 只提供渲染，而不是其他的能力，如果你需要 像网络，图片，URL跳转这些特性，需要自己动手实现他们例如，如果你想实现一个url地址跳转函数，你可以按照如下步骤实现一个 Module 自定义module的步骤# 自定义的module类 必须实现 WXModuleProtocol 必须添加宏WX_EXPORT_METHOD, 它可以被weex识别，它的参数是 JavaScript调用 module指定方法的参数 添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上 Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行 Weex 的参数可以是 String 或者Map Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map @implementation WXEventModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end 暴露同步方法v0.10+#如果你想要暴露同步的native方法给JS， 即JS可以直接拿到Native的返回值。 你可以使用WX_EXPORT_METHOD_SYNC 宏。 native 代码: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString))- (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js 代码: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" 除了string, 你也可以返回 number/array/dictionary 类型. 注意: 暴露的同步方法只能在 JS 线程执行，请不要做太多同步的工作导致JS执行阻塞。 注意: Vue 2.0 还未支持这个特性，最早会在 0.12 版本支持 注册 module#通过调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; 使用自己的 module#这里的 require 里面的 event 就是在 上一步调用 registerModule: 注册 module 时候的 name var eventModule = weex.requireModule('event');eventModule.openURL('url',function(ret) &#123; nativeLog(ret);&#125;); Weex SDK 没有 图片下载，navigation 操作的能力，请大家自己实现这些 protocol WXImgLoaderProtocol#weexSDK 没有图片下载的能力，需要实现 WXImgLoaderProtocol, 参考下面的例子 WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/*** @abstract Creates a image download handler with a given URL* @param imageUrl The URL of the image to download* @param imageFrame The frame of the image you want to set* @param options : The options to be used for this download* @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished.*/-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end 实现上述协议 @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end handler注册#你可以通过WXSDKEngine 中的 registerHandler:withProtocol注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] Components 扩展#虽然 WeexSDK 中有很多的 native 的 Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫 native 的组件，想包装一下，导入到 Weex 中，因此我们提供了让开发者实现自己的 native Component。下面将以 WeexSDK 中已经存在的 Component：image 为例子，介绍一下如何构建一个 native Component。假设你已经了解 iOS 开发 注册 Component#注册一个 component 比较简单，调用 WXSDKEngine 中的 registerComponent:withClass: 方法，传入组件的标签名称，还有对应的 class 然后你可以创建一个 WXImageComponent 表示 image 组件的实现。在 .we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性#现在我们要做一些让 image component 更加强大的事情。既然作为一个图片的 component，那它应该要有源，给他加上一个 src 的属性，同时给它加上一个 resize 的属性（可以配置的有 contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component 中所有的 style，attribute，events 都会被传递到 Component 的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute 中拿到的值的类型都是 id，我们可以用转换方法把它转换到任何值。Weex SDK 提供了一些基础的转换方法，可以参考 WXConvert 类，或者你可以添加自己的转换函数。 Hooking 渲染生命周期#native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 在 image component 的例子里面，如果我们需要我们自己的 image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123;return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。作为一个 image component，我们需要拿到服务器图片，而且把它设置进 image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在 view 已经被创建而且加载了时候 Weex SDK 会调用到，而且 viewDidLoad 这个方法是你做额外初始化工作比如改变 content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变 image 的 src，也可以 hook updateAttributes: 方法来做属性更新操作，当 updateAttributes: 或者 updateStyles: 被调用的时候， component 的 view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 现在你可以用在任何 .we 文件里面使用 &lt;image&gt;，而且可以加上 image 的属性。 &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; component 方法#WeexSDK 0.9.5 之后支持了在 js 中直接调用 component 的方法，这里提供一个例子 自定义一个 WXMyCompoenent 的组件 @implementation WXMyComponentWX_EXPORT_METHOD(@selector(focus)) // 暴露该方法给js- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self;&#125;- (void)focus&#123; NSLog(@&quot;you got it&quot;);&#125;@end 注册组件 [WXSDKEngine registerComponent:@&quot;mycomponent&quot; withClass:[WXMyComponent class]] 在 weex 文件中调用 &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"集成 Devtools 到 iOS","path":"cn/guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-ios.html","text":"集成 Devtools 到 iOS#Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入#添加依赖#方法一：cocoapods 依赖#在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， 目前有如下几个版本： 0.7.0, 0.6.1, 0.1.1, 0.1.0 [master repo] 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 推荐在DEBUG模式下依赖。 方法二：github 源码依赖# 拉取最新的WXDevtool代码。 按照如下图示：直接拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网 App 研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能#如果按照方法一接入：podfile 的方式，添加头文件包含： #import &lt;TBWXDevtool/WXDevtool.h&gt; 如果按照方法二接入：源码依赖的方式，添加头文件包含： #import &quot;WXDevtool.h&quot; 查看 WXDevtool 头文件如下： #import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */+ (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end setDebug：参数为 YES 时，直接开启 debug 模式，反之关闭，使用场景如下所述 在你自己的程序中添加如下代码： [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能# 为什么需要页面刷新功能？ 如下图所示，当点击 debugger 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debugger 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 具体实现可参考 playground WXDemoViewController.m 文件 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 使用#如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 日志级别控制 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0,Error = ErrorWarning = Error | Warning,Info = Warning | Info,Log = Log | Info,Debug = Log | Debug,All = NSUIntegerMax 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"guide"},{"title":"集成 Weex 到已有应用","path":"cn/guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/cn/guide/integrate-to-your-app.html","text":"集成 Weex 到已有应用#集成到 Android#注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式# 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备# 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入#如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现#注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio)# 下载源码 git clone https://github.com/alibaba/weex 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录#WXSample地址 https://github.com/xkli/WXSample.git 集成到 iOS#通过 或者 集成 Weex iOS SDK到你的项目#首先假设你已经完成了安装 iOS 开发环境 和 CocoaPods(或者Carthage) 第一步：添加依赖#导入 Weex iOS SDK 到你已有的项目, 如果没有，可以参考新建项目。在继续下面内容之前，确保你已有的项目目录有名称为 Podfile 文件，如果没有，创建一个，用文本编辑器打开(如果使用 Carthage ，请确保已有项目目录下存在 Cartfile)。选择其中一个集成方法就可以。 添加依赖 使用CocoaPodsWeexSDK 在 cocoaPods 上最新版本 可以在这获取 在 Podfile 文件中添加如下内容 source &apos;git@github.com:CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.17.0&apos; ## 建议使用WeexSDK新版本 end ``` 打开命令行，切换到你已有项目 `Podfile` 这个文件存在的目录，执行 `pod install`，没有出现任何错误表示已经完成环境配置。 - 使用 [Carthage](https://github.com/Carthage/Carthage) 可以在[这](https://github.com/apache/incubator-weex/tags)查询到当前最新的版本。 在 [`Cartfile`](https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile) 中添加如下内容 `github &quot;apache/incubator-weex&quot;` 在包含 `Cartfile` 文件目录的终端中执行 `carthage update`。 [添加 framework 到你的工程](https://github.com/Carthage/Carthage#adding-frameworks-to-an-application)#### 第二步：初始化 Weex 环境在 `AppDelegate.m` 文件中做初始化操作，一般会在 `didFinishLaunchingWithOptions` 方法中如下添加。 //business configuration[WXAppConfiguration setAppGroup:@”AliApp”];[WXAppConfiguration setAppName:@”WeexDemo”];[WXAppConfiguration setAppVersion:@”1.0.0”]; //init sdk environment[WXSDKEngine initSDKEnvironment]; //register custom module and component，optional[WXSDKEngine registerComponent:@”MyView” withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@”event” withClass:[WXEventModule class]]; //register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)]; //set the log level[WXLog setLogLevel: WXLogLevelAll];#### 第三步：渲染 weex InstanceWeex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 Weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController。```objective-c#import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如 renderWithURL, onCreate, onFailed 等，可以参见 WXSDKInstance.h 的声明。 第四步：销毁 Weex Instance# 在 viewController 的 dealloc 阶段 销毁掉 Weex instance，释放内存，避免造成内存泄露。 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework 到工程# 可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature。 使用 git clone WeexSSH git clone git@github.com:apache/incubator-weex.git ``` 或者 https ``` git clone https://github.com/apache/incubator-weex.git 打开 WeexSDK.xcodeproj in weex/ios/sdk切换到如下图所示 target 编译当前target，可以直接用快捷键 ⌘ + b 最后找到产物在 weex/ios/sdk/Products 目录 导入 framework 到自己工程 需要添加如下图系统依赖 添加 -ObjC 到工程设置中 添加 js-framework 到自己的 main bundle, js-framework 的位置在 WeexSDK.framework 中，文件名称为 native-bundle-main.js","type":"guide"},{"title":"集成 Devtools 到 Android","path":"cn/guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-android.html","text":"集成 Devtools 到 Android#Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入#添加依赖#可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:$&#123;version&#125;'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容# weex sdk weex inspector Debugger Server 0.13+ 0.12+ 0.2.39+ 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 0.16.0+ 0.12.1 - 0.17.0+ 0.13.2 - 添加 Debug 模式开关#控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 更详细和合适的位置,初始化 inspector 的方法请参考 Playground. private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用`WXSDKEngine.reload()。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例#最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含 DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试#前置工作#如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug,最新的版本我们建议您使用 weex debugx 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get Started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试#如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下# 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识#Devtools 组件介绍#Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ#在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。 注入自定义WebSocket Client#目前Inspector以反射的方式动态调用了okhttp-ws库中的相关代码，可以兼容的okhttp与okhttp-ws版本为： okhttp, okhttp-ws 2.7.5版本以下 okhttp3, okhttp3-ws 3.5版本以下 如果客户端中集成的版本与上述版本不匹配，则可以使用WeexInspector.overrideWebSocketClient方法来注入自定义的WebSocket实现，示例：public class CustomWebSocketClient implements IWebSocketClient &#123; private WebSocket ws; @Override public boolean isOpen() &#123; return ws != null; &#125; @Override public void connect(String wsAddress, final WSListener listener) &#123; OkHttpClient okHttpClient = new OkHttpClient(); okHttpClient.setConnectTimeout(5, TimeUnit.SECONDS); okHttpClient.setReadTimeout(5, TimeUnit.SECONDS); okHttpClient.setWriteTimeout(5, TimeUnit.SECONDS); Request request = new Request.Builder().url(wsAddress).build(); WebSocketCall webSocketCall = WebSocketCall.create(okHttpClient, request); webSocketCall.enqueue(new WebSocketListener() &#123; @Override public void onOpen(WebSocket webSocket, Request request, Response response) throws IOException &#123; ws = webSocket; listener.onOpen(); &#125; @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException &#123; if (WebSocket.PayloadType.TEXT == type) &#123; listener.onMessage(payload.readUtf8()); &#125; &#125; @Override public void onPong(Buffer payload) &#123; //ignore &#125; @Override public void onClose(int code, String reason) &#123; listener.onClose(); &#125; @Override public void onFailure(IOException e) &#123; listener.onFailure(e); &#125; &#125;); &#125; @Override public void close() &#123; if (ws != null) &#123; try &#123; ws.close(CloseCodes.NORMAL_CLOSURE, \"Normal closure\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void sendMessage(int requestId, String message) &#123; if (ws != null) &#123; try &#123; ws.sendMessage(WebSocket.PayloadType.TEXT, new Buffer().writeString(message, Charset.defaultCharset())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","type":"guide"},{"title":"搭建开发环境","path":"cn/guide/set-up-env.html","permalink":"https://weex.apache.org/cn/guide/set-up-env.html","text":"搭建开发环境#使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本节会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖#Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试。首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.11.3$ npm -v3.10.10 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 注意: 在weex-toolkit1.0.8\b版本后添加了npm5规范的npm-shrinkwrap.json用于锁定包依赖，故npm版本&lt;5的用户需要通过npm i npm@latest -g更新一下npm的版本，使用前请确认版本是否正确。 $ npm install -g weex-toolkit$ weex -v //查看当前weex版本 weex-toolkit也支持直接升级子依赖，如：weex update weex-devtool@latest //@后标注版本后，latest表示最新 国内开发者可以考虑使用淘宝的 npm 镜像 —— cnpm 安装 weex-toolkit $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第二步：初始化#然后初始化 Weex 项目： $ weex create awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 第三步：开发#之后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启HotReload服务器，代码改动的将会实时同步到网页中 我们先通过 npm install 安装项目依赖。之后运行根目录下的 npm run dev &amp; npm run serve 开启 watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 weex h5 页面。 初始化时已经为我们创建了基本的示例，我们可以在 src/index.vue 中查看。 代码如下所示： &lt;template&gt; &lt;div class=\"wrapper\" @click=\"update\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;text class=\"desc\"&gt;Now, let's use vue to build your weex app.&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; padding-top:40px; padding-bottom: 40px; font-size: 48px; &#125; .logo &#123; width: 360px; height: 156px; &#125; .desc &#123; padding-top: 20px; color:#888; font-size: 24px;&#125;&lt;/style&gt;&lt;script&gt; export default &#123; data: &#123; logoUrl: 'http://img1.vued.vanthink.cn/vued08aa73a9ab65dcbd360ec54659ada97c.png', target: 'World' &#125;, methods: &#123; update: function (e) &#123; this.target = 'Weex' console.log('target:', this.target) &#125; &#125; &#125;&lt;/script&gt; 关于 Weex 语法部分，你可以直接参考 Vue Guide，这里不再重复介绍。如果您想了解有关技术详情的更多信息，请继续阅读下一节。并且不要忘记在 dotWe 写代码并随时预览。","type":"guide"},{"title":"BroadcastChannel","path":"cn/references/broadcast-channel.html","permalink":"https://weex.apache.org/cn/references/broadcast-channel.html","text":"API 通信过程 使用范例 注意事项 BroadcastChannel 接口在 v0.9+ 及以上的版本中可用。 在 JS 执行环境中提到过，不同的 Weex 页面使用的是不同的执行环境，即使全局变量也是互相隔离的，然而使用 BroadcastChannel 是可以实现跨页面通信的。 API# BroadcastChannel 是 W3C 规范中的一部分，其中依赖的 MessageEvent 对象也是。 BroadcastChannel 的构造函数只接受一个参数，那就是“频道名称”（channel name）。 const jb = new BroadcastChannel('007') BroadcastChannel 接口的定义如下： declare interface BroadcastChannel = &#123; name: string, postMessage: (message: any) =&gt; void; onmessage: (event: MessageEvent) =&gt; void; close: () =&gt; void;&#125; name: 监听的频道名称，用来区分不同的频道（跨频道不可通信）。 postMessage: 用于在当前频道中广播消息。 onmessage: 消息事件的处理函数。在频道中接收到广播消息之后，会给所有订阅者派发消息事件。 close: 关闭当前频道。 消息对象（MessageEvent）的类型定义如下： declare interface MessageEvent = &#123; type: string, // \"message\" data: any&#125; 通信过程# 就像使用无线电一样，每个页面通过创建一个具有相同频道名称的 BroadcastChannel 对象来加入特定频道。 然后实现 onmessage 接口来监听消息事件。通过调用 BroadcastChannel 对象上的 postMessage() 方法可以在频道中广播一条消息给所有订阅者。 事实上，这是在特定频道的所有用户之间的全双工（双向）通信，每个订阅者都可以在频道中彼此收发任何消息，即使消息的发送者也能收到自己发出的消息事件。不同频道之间的通信过程是不会互相影响的。 调用 BroadcastChannel 对象的 close() 方法可以离开一个频道，这个方法只关闭自己，并不影响其他订阅者。当某个 Weex 页面被销毁时，其中的所有订阅者将在 destroyInstance 中强制关闭。如果某个频道的所有用户都关闭了，这个频道对象将会被销毁，所占内存页能被回收。 使用范例#在页面 A 中： const Steve = new BroadcastChannel('Avengers')Steve.postMessage('Assemble!') 在页面 B 中： const Hulk = new BroadcastChannel('Avengers') 在页面 C 中： const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // Assemble! Stack.postMessage('I am Tony and I am leaving now.')&#125; 页面 A 、B 、C 都创建一个监听了 &#39;Avengers&#39; 频道的 BroadcastChannel 对象，它们可以用这个对象实现互相通信。 当 Steve 发布了 &#39;Assemble!&#39; 消息时，Stack 将收到一个消息事件，其 data 字段等于 &#39;Assemble!&#39;，然后也向频道中回复一条消息。但是 Hulk 并不会收到这些消息，因为他没有实现onmessage 方法，相当于没有接收频道中的消息，所以他实际上不是一个订阅者。 注意事项# 消息事件中的对象并没有深度复制。（这个特性可能会修改） 在页面 A 中： const a = new BroadcastChannel('app')const list = ['A', 'B']a.postMessage(&#123; list &#125;) 在页面 B 中： const b = new BroadcastChannel('app')b.onmessage = function (event) &#123; // the `event.data.list` is a reference of `list` in page A event.data.list.push('C')&#125; 在这个例子中，页面 B 中的 event.data.list 实际上是页面 A 中 list 对象的引用。在页面 B 中给列表添加一项 &#39;C&#39;，也将影响到页面 A 中的 list 对象。 相比于深度复制，这个行为可以减少页面中的内存消耗。开发者在使用时不应该存储或修改 event 对象。","type":"references"},{"title":"在 Weex 中使用 Vue.js","path":"cn/guide/use-vue.html","permalink":"https://weex.apache.org/cn/guide/use-vue.html","text":"Working in progress. Please refer to the English version.","type":"guide"},{"title":"Android APIs","path":"cn/references/android-apis.html","permalink":"https://weex.apache.org/cn/references/android-apis.html","text":"Android APIs#Weex 初步接入请参考：https://github.com/weexteam/article/issues/25 WXSDKEngine 是 Weex 对外的总入口。#主要提供了一下功能： 设置相关 Adapter 和获取 adapter。 注册自定义 module 和 component 重置 JSFramework Adapter 介绍#Weex 为了重用 Native 通用库提供了对应的接口进行设置。 IWXImgLoaderAdapter 图片适配器。 Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。 Weex 没有提供图片默认实现。 接口定义如下： public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality 表示图片的质量，WXImageQuality 取如下值 LOW, NORMAL, HIGH, ORIGINAL 图片质量依次变高。默认为 LOW。WXImageStrategy 为扩展类，表示了图片是否可以裁剪 (isClipping) 锐化 (isSharpen) 占位符 (placeHolder) 等。 IWXHttpAdapter 网络下载适配器。 Weex 自定义了 WXRequest 和 OnHttpListener，Native 重载接口后可以从 Request 中获取URL，Header 等参数，网络请求完成后可以通过 OnHttpListener 进行回调通知。Weex 提供了默认网络请求：DefaultWXHttpAdapter， 使用的是 HttpURLConnection 进行网络请求。 接口定义如下： public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest 定义了网络请求相关的参数，请求方法，请求主体，超时时间。Weex默认超时时间是3000. OnHttpListener 定义了网络请求结束后对应方法。定义如下： interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response);&#125; IWXUserTrackAdapter Weex 相关性能数据 (首屏加载时间、JS-Native 通信时间、dom 更新时间等) 和其他通用信息 (JSLib 文件大小, Weex SDK 版本号等)。 接口定义： public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native 实现接口后可以通过 WXPerformance 和 params 获取对应的信息。WXPerformane 对应字段表示含义请参考文档：https://github.com/weexteam/article/issues/124 后续随着开发 Weex 还会定义更多的 Adapter，此文档也会定时更新。 Native 和 JS 通信# 自定义事件通知 多用于某个自定义控件进行事件通知，例如自定义点击事件，响应下拉事件等。 WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：事件发生的控件 ID。 type: 自定义事件，Weex 默认以 onXxxxx 开头为自定义事件。onPullDown (下拉事件)。 data: 需要透出的参数，例如当前控件的大小，坐标等其他信息。 domChanges：更新 ref 对应控件的 Attribute 和 Style。 事件回调 多用于 Module 回调，例如定位 Module 完成后需要通知 JS。使用方法如下： public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //获取定位代码..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //通知一次 callback.invoke(data); //持续通知 callback.invokeAndKeepAlive(data); //invoke方法和invokeAndKeepAlive两个方法二选一 &#125;&#125; 注册滑动事件#Weex 获取滑动事件可以通过 WXSDKInstance 注册 registerOnWXScrollListener 监听 接口定义如下： public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; 自定义NavBar#Weex 提供了 WXNavigatorModule 进行导航控制，对应的方法可以通过设置 IActivityNavBarSetter 接口进行定制。 使用方法: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); 其他介绍#动态适配容器#因为 Android 手机的碎片化导致屏幕适配很困难。Weex 对外提供的接口 render 需要动态传入容器的宽高，但是传入的宽高有时会发生变化，例如 ActionBar 隐藏等，这是传入的 Weex 容器也要进行对应的变化。为了适应这种变化，Weex 提供了接口 WXSDKInstance.setSize(int width, int height) 来改变容器的大小。 /** * * @param width 容器宽度 * @param height 容器高度 */ public void setSize(int width, int height)&#123;&#125;; 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 IWXRenderListener 中的 onException 方法进行处理，如果是主动降级 errCode 是以“|”分割的字符。“|”前面的字符为1表示主动降级，Native 端可以跳转到对应的 H5 页面。或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"iOS APIs","path":"cn/references/ios-apis.html","permalink":"https://weex.apache.org/cn/references/ios-apis.html","text":"iOS APIs#Native 对外接口# 注册 SDK 默认的 Module、Handler 和 Component 注册自定义 module、Handler 和 Component 重置 JSFramework Handler (对应于 Android 的 Adapter) 介绍# WXImgLoaderDefaultImpl 图片下载 handler。Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。WeexSDK kernel 本身没有提供图片下载的默认实现。 接口定义如下： @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native 和 JS 通信# 自定义通知事件 用于 native 自定义部分和 js 进行实践通知，比如传递下拉事件到 js，这个是在 component 基类的方法，可以直接使用 /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName 事件名称，可以在weex文件某个标签组件监听，命名规范为 onXXX * @param params 数据 * @param domChanges 发生改变的数据 **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges 事件回调 多用于 Module 回调结果给 js，回调类型分为下面两种： WXModuleCallback 为了性能考虑，该回调只能回调通知js一次，之后会被释放，多用于一次结果 WXModuleKeepAliveCallback 该回调可以设置是否为多次回调类型，多次回调的场景如持续监听位置的变化，并返回给 js。 @implementation WXEchoModule@synthesize weexInstance; // 让该module 获得当前instanceWX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);// 此处设置true，该回调function 可以多次回调执行，可以写循环测试.&#125; 动态适配容器#WeexSDK 在 WXSDKInstance 类中提供了方法 setFrame(CGRect) 来改变容器的大小。 如：在导航栏从有到无过程，需要 weexView 的变化， 可以在此时 native 调用该方法设置 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 WXSDKInstance 中的 onFailed 回调进行处理，如果是主动降级则返回的错误 domain 为 TemplateErrorType，Native 端可以跳转到对应的 H5 页面，或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"Weex 实例变量","path":"cn/references/weex-variable.html","permalink":"https://weex.apache.org/cn/references/weex-variable.html","text":"属性和方法 weex.config Weex 环境变量 weex.document weex.requireModule 使用原生模块 weex.supports 使用范例 每个 Weex 页面的 JS 上下文中都有一个相互独立的 weex 变量，它可以像全局变量一样使用，不过它在不同页面中是隔离而且只读的。 注意： weex 实例变量只在 Vue 框架中暴露了，目前还不支持在 Rax 框架中使用。 属性和方法#Weex 实例变量的类型定义如下： declare type Weex = &#123; config: WeexConfigAPI; document: WeexDocument; requireModule: (name: string) =&gt; Object | void; supports: (condition: string) =&gt; boolean | void;&#125; weex.config#该变量包含了当前 Weex 页面的所有环境信息。 declare type WeexConfigAPI = &#123; bundleUrl: string; bundleType?: string; env: WeexEnvironment;&#125; bundleUrl: 当前页面 js bundle 的 URL 地址。 bundleType: v0.17+ 页面 js bundle 的类型，它表示的是当前页面是用那种框架开发的，可以是 &quot;Vue&quot; 或者 &quot;Rax&quot;。 env: Weex 环境变量。 Weex 环境变量#有时候为了兼容性或者为了增强某个端上的能力，需要编写平台特异的代码。 Weex 提供了 weex.config.env 和全局的 WXEnvironment 变量（它们是等价的）来获取当前执行环境的信息。 weex.config.env === WXEnvironment Weex 环境变量中的字段: 字段名 类型 描述 platform String Current running platform, could be “Android”, “iOS” or “Web”. weexVersion String The version of Weex SDK. appName String Mobile app name or browser name. appVersion String The version of current app. osName String The OS name, could be “Android” or “iOS”. osVersion String The version of current OS. deviceModel String Mobile phone device model. (native only) deviceWidth Number Screen resolution width. deviceHeight Number Screen resolution height. 这个例子 打印出了 Weex 环境对象中的所有值。 weex.document#weex.document 是当前页面的文档模型对象，可以用来创建和操作 DOM 树中元素。它是 Weex DOM API 规范的一部分，但是它和 W3C 的 DOM 规范中的 document 对象是不同的。 而且，在使用了现代化的前端框架（如 Vue 和 Rax）的情况下，直接操作 DOM 并不是最佳实践。更何况在 Weex 平台里并不一定有真实的 DOM，在 Android 和 iOS 端上都是模拟出来的。 这个接口主要是用在 Vue 和 Rax 框架内部，用于将 virtual-dom 转换成渲染执行，并且发送给 Weex 客户端的渲染引擎。不建议在开发页面时使用。 weex.requireModule#对于那些不依赖 UI 交互的原生功能，Weex 将其封装成模块，这是一种通过 javascript 调用原生能力的方法。除了内置模块以外，将已有的原生模块移植到 Weex 平台也很方便。你可以使用 weex.requireModule 接口引用自定义的或者内置的模块。 weex.requireModule(name: string): Object | void; 参数： 大小写敏感的模块名。 返回值： 如果模块已经注册了，返回一个 Proxy 对象（如果环境不支持 Proxy 则返回一个普通对象），可以使用这个对象调用客户端注册的方法。 如果模块未注册，返回 undefined。 使用原生模块#你可以像使用不同 javascript 函数一样使用原生注册的接口。这里是一个简单的使用 modal 模块的例子： &lt;template&gt; &lt;div&gt;&lt;text&gt;Toast&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.supports# 这个接口只在 v0.15+ 或以上的版本可用。 你应该了解 Weex 的组件和模块都是可以注册和配置的，这样导致了在不同环境中组件和模块的支持情况不一样。你可以使用 weex.supports 接口在运行期检测某个功能在当前环境中是否可用。 weex.supports(condition: string): boolean | void; 参数： 特定格式的字符串：@{type}/{name}。 type 必须是 &quot;component&quot; 和 &quot;module&quot; 之一。name 可以是标签名、模块名，也可以指定模块中的某个方法名（和模块名用 . 隔开）。 返回值： 支持该特性，则返回 true。 不支持该特性，则返回 false。 参数格式错误或无法确定是否支持，则返回 null。 使用范例#检测某个组件是否可用： weex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false 检测某个模块是否可用： weex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false 检测某个模块是否包含某个方法： weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false 无效的输入： weex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null","type":"references"},{"title":"JS Service","path":"cn/references/js-service.html","permalink":"https://weex.apache.org/cn/references/js-service.html","text":"JS Service#v0.9.5+ JS service 和 Weex 实例在 JS runtime 中并行运行。Weex 实例的生命周期可调用 JS service 生命周期。目前提供创建、刷新、销毁生命周期。 重要提醒: JS Service 非常强大但也很危险，请小心使用！ 注册 JS Service#iOS#[WeexSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;!-- 必须在 JSFM 之后加载 --&gt;&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; 编写一个 JS service#// options: native inject options// options.serviceName is native options nameservice.register(options.serviceName, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: fucntion() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"Weex语法支持插件","path":"cn/tools/helpers.html","permalink":"https://weex.apache.org/cn/tools/helpers.html","text":"Weex语法支持插件#Weex Language Support 插件是官方提供的一个工具，你可以使用它在IntelliJ IDEA，WebStorm等一系列IDE上对Weex DSL进行语法高亮，自动补全和错误检查等操作。 支持的IDE#你可以在任何操作系统上的下列IDE上安装和使用Weex Language Support插件：IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider 安装#在IDE的插件仓库中搜索Weex Language Support来安装该插件，安装完毕后重启IDE即可激活插件相关功能 配置#打开Preferences -&gt; Other Settings -&gt; Weex language support可配置插件的相关功能 Target Weex Version: 配置插件以哪一个版本的语法规则来对DSL进行提示及检查，默认值LATEST表示总是应用最行\b\b新版本weex的语法规则 Vue Support: 配置插件是否支持Weex 2.0版本的DSL(.vue文件)，开启后重启生效（注意：如果IDE内有其他支持Vue语法的插件，则需要关闭相应的插件后Weex插件才能生效） Custom Rules: 引入自定义的Weex DSL规则，如果你在native中定义了自己的Module或Component，可通过自定义规则引入插件中来提供相应的提示和补全支持，自定义规则的\b格式将在后文列出 Global Weex Components: 默认地，插件会解析当前工程及npm root路径下的node_modules\b目录，解析其中包含的Weex Components并对其提供补全支持。如果你的项目中引用了这两个路径以外的Components，可以在此处将其添加到搜索路径中，\b插件将会将其中的Components载入，并在编写DSL时为相应的标签提供补全支持 自定义规则格式#自定义规则包含在一个json文件中，json文件的根节点为数组类型，数组中的每一个元素对应DSL中的一个标签。我们以&lt;loading&gt;标签的规则来举例：&#123; \"tag\": \"loading\", //标签名，不可为空 \"attrs\": [ //标签属性列表，可为空 &#123; \"name\": \"display\", //属性名，不可为空 \"valuePattern\": null, //属性值的正则表达式，用于检测\b值是否合法，可为空 \"valueEnum\": [ //属性值枚举，可为空 \"show\", \"hide\" ], \"valueType\": \"var\", //属性值类型，必须是var或function，决定该从数据列表还是函数列表中查找属性值补全的候选值，不可为空 \"since\": 0, //该属性何时被添加到sdk中，例如0.11，\b默认为0 \"weexOnly\": false //该属性是否仅在1.0语法中可用，默认为false &#125; ], \"events\": [ //事件列表。可为空 &#123; \"name\": \"loading\", //事件名称，不可为空 \"since\": 0 //该事件何时被添加到sdk中 &#125; ], \"parents\": [ //该标签允许被作为哪些标签的子元素，空表示可以作为任意元素的子元素 \"list\", \"scroller\" ], \"childes\": [ //该标签允许哪些元素作为自己的子元素，空表示任意元素都可作为子元素 \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //文档地址，配置该属性之后可在编辑界面中对应的标签上直接打开文档 &#125; 使用#插件的绝大部分功能\b被集成到编辑器上下文中，会随用户输入在需要补全，提示或Lint时被触发，无需特殊干预。下列功能需要用户手动触发： 文档搜索#打开IDE右侧工具栏的Weex Documents即可对文档进行搜索，搜索结果与官网保持同步，勾选 EN 可切换搜索结果为英文内容 打开标签对应的文档#\b将光标定位到标签上，并通过Show Intention Actions操作（OSX上默认键为 option + enter，可通过Keymap查看）打开Intenion菜单，\b选择Open Document可打开标签对应的文档 参与插件建设#请将Issues及Pull Requests提交到weex-language-support项目中","type":"tools"},{"title":"使用 weex-toolkit","path":"cn/tools/toolkit.html","permalink":"https://weex.apache.org/cn/tools/toolkit.html","text":"weex-toolkit#weex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 安装#$ npm install -g weex-toolkit 如果你本地没有安装 node.js 你可以前往官网下载安装。 请确保你的 node 版本是&gt;=6，你可以使用 n 来进行 node 的版本管理。 中国用户如果npm遭遇网络问题，可以使用淘宝的 npm镜像或通过nrm工具切换你的npm镜像： $ npm install weex-toolkit -g --registry=https://registry.npm.taobao.org// 或者$ nrm use taobao$ npm install weex-toolkit -g 如果你安装的过程中遇到了问题，你可以在weex-toolkit问题汇总中找到解决方法或者在weex-toolkit issues中与我们讨论。 命令#create#$ weex create awesome-project 该命令用于创建一个新的weex项目。命令运行后，你可以找到awesome-project目录，里面有一些Weex模板,里面提供了一些内置的脚本 build: 用于打包源文件生成JS bundle dev: 运行监听模式的webpack打包脚本 serve: 启动热更新静态服务器 你需要在运行npm start前运行一下npm i来安装项目依赖，之后浏览器就会自动打开开发页面。 preview#weex-toolkit supports previewing your Weex file(.we or .vue) in a watch mode. You only need specify your file path.weex-toolkit工具支持对你的Weex文件（.vue)在监听模式下进行预览，你只需要指定一下你的项目路径。 $ weex src/foo.vue 浏览器会自动得打开预览页面并且你可以看到你的weex页面的布局和效果。如果你在你的设备上安装了Playground，你还可以通过扫描页面上的二维码来查看页面。 使用下面的命令，你将可以预览整个文件夹中的.vue文件 $ weex src --entry src/foo.vue 你需要指定要预览的文件夹路径以及入口文件（通过--entry传入）。 compile#使用 weex compile 命令可以编译单个weex文件或者整个文件夹中的weex文件。 $ weex compile [source] [dist] [options] 参数# Option Description -w, --watch watch we file changes auto build them and refresh debugger page! [default true] -d,--devtool [devtool] set webpack devtool mode -e,--ext [ext] set enabled extname for compiler default is vue we -m, --min set jsbundle uglify or not. [default false] 你可以这样子使用： $ weex compile src dest --devtool source-map -m platform#使用weex platform [add|remove] [ios|android]命令可以添加或移除ios/android项目模板。 $ weex platform add ios$ weex platform remove ios 使用 weex platform list来查看你的项目中支持的平台。 run#你可以使用weex-toolkit来运行android/ios/web项目. $ weex run ios$ weex run android$ weex run web debug# Weex devtools 是实现Chrome调试协议的Weex自定义开发工具,主要用于帮助你快速检查您的应用程序，并在Chrome网页中调试您的JS bundle源代码，支持Android和iOS平台。所以你可以通过weex-toolkit使用的weex-devtool功能。 用法#weex debug [we_file|bundles_dir] [options] 参数# Option Description -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer loader] -w, --watch watch we file changes auto build them and refresh debugger page! [default true] --ip [ip] set the host ip of debugger server --loglevel [loglevel] set log level `silent error warn info log debug` --min set jsbundle uglify or not. [default false] --debug start with node-inspect default port is 9331 特性#连接设备#$ weex debug 这个命令将启动调试服务器并启动一个打开“DeviceList”页面的chrome。这个页面会显示一个二维码，你可以使用Playground来扫描它来启动调试或者在你的应用中集成Weex devtools 调试.vue文件#$ weex debug your_weex.vue 这个命令会将your_weex.vue编译成your_weex.js，并根据命令启动调试服务器。your_weex.js将部署在服务器上并显示在调试页面中，使用另一个二维码用于your_weex.js文件的调试。 调试文件夹中的.vue文件#$ weex debug your/vue/path -e index.vue 这个命令将编译your/vue/path中的每个文件，并将它们部署在捆绑服务器上，新的文件将映射到http://localhost:port/weex/路径下，使用-e指定的路径作为页面的入口。 Inspector# Inspector 能够用来查看 Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View 等。 Element# NetWork# 查看网络请求的总耗时和延时# 查看网络请求的header和response# 控制台# 资源# 调试# 调试器用来调试 Weex 中的 JS 代码，能够设置断点、查看调用栈。 Breakpoint and CallStack# 集成devtool工具# Android 查看文档 Weex devtools (Android), 它会引导你一步一步配置和使用它。 iOS 查看文档 Weex devtools (iOS), 它会引导你一步一步配置和使用它。","type":"tools"},{"title":"颜色名称列表","path":"cn/wiki/color-names.html","permalink":"https://weex.apache.org/cn/wiki/color-names.html","text":"Weex 支持的所有颜色名称#基础颜色关键词:# 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词:# 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"通用事件","path":"cn/wiki/common-events.html","permalink":"https://weex.apache.org/cn/wiki/common-events.html","text":"通用事件#Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click#当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 longpress#如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 Appear 事件#如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象# type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Disappear 事件#如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象# type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Page 事件#注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象# type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"CSS 单位","path":"cn/wiki/css-units.html","permalink":"https://weex.apache.org/cn/wiki/css-units.html","text":"CSS 单位#CSS color 单位#支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意# 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位#在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位#仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持)#表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"wiki"},{"title":"通用样式","path":"cn/wiki/common-styles.html","permalink":"https://weex.apache.org/cn/wiki/common-styles.html","text":"通用样式#所有 Weex 组件都支持以下通用样式规则。 盒模型# Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：#Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 &lt;image&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例：#&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400px; height: 200px; margin-left: 20px;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器#在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项#flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例#一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div v-for=\"(v, i) in list\" class=\"row\"&gt; &lt;div v-for=\"(text, k) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80px; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200px; height: 200px; background-color: #fc0000; &#125;&lt;/style&gt; 定位#Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例# &lt;template scoped&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400px; height: 400px; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150px; left: 150px; background-color: #0055dd; &#125; .box3 &#123; top: 300px; left: 300px; background-color: #00ff49; &#125;&lt;/style&gt; transform#transform 属性向元素应用 2D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 目前支持的 transform 声明格式: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) rotateX( ) v0.14+ rotateY( ) v0.14+ perspective( ) Android 4.1及以上版本支持 v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.16.0+#现在您可以在CSS中使用transition属性来提升您应用的交互性与视觉感受，transition中包括布局动画，即LayoutAnimation，现在布局产生变化的同时也能使用transition带来的流畅动画。transition允许CSS的属性值在一定的时间区间内平滑地过渡。 参数# transition-property:允许过渡动画的属性名，设置不同样式transition效果的键值对，默认值为空，表示不执行任何transition，下表列出了所有合法的参数属性： 参数名 描述 width transition过渡执行的时候是否组件的宽度参与动画 height transition过渡执行的时候是否组件的高度参与动画 top transition过渡执行的时候是否组件的顶部距离参与动画 bottom transition过渡执行的时候是否组件的底部距离参与动画 left transition过渡执行的时候是否组件的左侧距离参与动画 right transition过渡执行的时候是否组件的右侧距离参与动画 backgroundColor transition过渡执行的时候是否组件的背景颜色参与动画 opacity transition过渡执行的时候是否组件的不透明度参与动画 transform transition过渡执行的时候是否组件的变换类型参与动画 transition-duration:指定transition过渡的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 transition-delay:指定请求transition过渡操作到执行transition过渡之间的时间间隔 (单位是毫秒或者秒)，默认值是 0，表示没有延迟，在请求后立即执行transition过渡。 transition-timing-function:描述transition过渡执行的速度曲线，用于使transition过渡更为平滑。默认值是 ease。下表列出了所有合法的属性： 属性名 描述 ease transition过渡逐渐变慢的过渡效果 ease-in transition过渡慢速开始，然后变快的过渡效果 ease-out transition过渡快速开始，然后变慢的过渡效果 ease-in-out transition过渡慢速开始，然后变快，然后慢速结束的过渡效果 linear transition过渡以匀速变化 cubic-bezier(x1, y1, x2, y2) 使用三阶贝塞尔函数中自定义transition变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. 示例#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; 伪类 v0.9.5+#Weex 支持四种伪类：active, focus, disabled, enabled 所有组件都支持 active, 但只有 input 组件和 textarea 组件支持 focus, enabled, disabled。 规则# 同时生效的时候，优先级高覆盖优先级低 例如：input:active:enabled 和 input:active 同时生效，前者覆盖后者 互联规则如下所示 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; 试一下 线性渐变 v0.10+#Weex 支持线性渐变背景，具体介绍可参考 W3C description of the gradient。 所有组件均支持线性渐变。 使用# 你可以通过 background-image 属性创建线性渐变。 background-image: linear-gradient(to top,#a80077,#66ff00); 目前暂不支持 radial-gradient（径向渐变）。 Weex 目前只支持两种颜色的渐变，渐变方向如下： to right从左向右渐变 to left从右向左渐变 to bottom从上到下渐变 to top从下到上渐变 to bottom right从左上角到右下角 to top left从右下角到左上角 Note# background-image 优先级高于 background-color，这意味着同时设置 background-image 和 background-color，background-color 被覆盖。 不要使用 background 简写. 示例#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; 阴影(box-shadow) v0.11+#Weex 支持阴影属性：active, focus, disabled, enabled inset(可选),offset-x,offset-y, blur-radius,color 注意# box-shadow仅仅支持iOS 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; 其他基本样式# opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式#如果对于样式写法需要更多上手参考，可参考每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"wiki"},{"title":"设计理念","path":"cn/wiki/design-principles.html","permalink":"https://weex.apache.org/cn/wiki/design-principles.html","text":"","type":"wiki"},{"title":"事件冒泡","path":"cn/wiki/event-bubble.html","permalink":"https://weex.apache.org/cn/wiki/event-bubble.html","text":"事件冒泡 v0.13+#Weex 2.0 实现了 W3C 标准的事件冒泡机制。 使用#&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播，依次触发。 注意#需要注意的是: 为了兼容之前的版本，Weex 默认不会开启事件冒泡机制。需要在根元素的属性上，添加 bubble=&quot;true&quot; 来开启冒泡机制。否则，将不会向上传播事件，保持与之前版本的效果相同。 stopPropagation#在事件处理函数中，可以使用 e.stopPropagation() 方法，来阻止本次事件向上的传递过程。注意，e.stopPropagation() 与 bubble=&quot;true&quot; 不同，前者只会影响当前元素以及父元素的传播，不会影响子元素的传播；后者是为了版本兼容而增加的开关机制，会全局关闭或者开启冒泡机制，两者可以共同存在使用，如下： &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播到父元素被终止，不再继续往根元素传播。","type":"wiki"},{"title":"手势","path":"cn/wiki/gestures.html","permalink":"https://weex.apache.org/cn/wiki/gestures.html","text":"手势#注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上设置 on 特性来监听手势即可。 手势类型#目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 shouldStopPropagation 每个touch事件都会被传递过来, 可控制touch事件是否冒泡（返回true）或者停止（返回false）；用于解决事件冲突或者自定义手势。v0.18+ Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三中类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend horizontalpan v0.10+：手势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 verticalpan v0.10+：势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性#以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedTouches#changedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 约束#目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。","type":"wiki"},{"title":"文本样式","path":"cn/wiki/text-styles.html","permalink":"https://weex.apache.org/cn/wiki/text-styles.html","text":"文本样式#v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性# color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}v0.9+：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考# 颜色关键字列表。","type":"wiki"},{"title":"与 Web 平台的差异","path":"cn/wiki/platform-difference.html","permalink":"https://weex.apache.org/cn/wiki/platform-difference.html","text":"Weex 和 Web 平台的差异#Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOM#DOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作#既然原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型#Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 并不支持 Web 中所有的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOM#BOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端没有并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象#Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象#在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象# history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API#在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。","type":"wiki"},{"title":"Mobile App Architecture","path":"guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/guide/advanced/app-architecture.html","text":"Mobile App Architecture#Today’s Mobile App#Let’s talk about what we think a mobile app should be. Mobile App Needs Parallel Development#Nowadays, all mobile app teams requires the ability to develop in parallel. When a mobile app keeps growing, supporting large-scale parallel development must become a very important key thing. Otherwise it’s really easy to become a bottleneck. Mobile App Needs to be Dynamic#Today the development of mobile apps is very heavy. And it’s really slow in iteration, release, distribution and online bugfix. The size of the package of an app is growing fast too. All of this is not suitable for this mobile internet age. Mobile app needs to be dynaimic which is out of the cumbersome process of version deployment and distribution. Mobile App Needs Open Interconnection#Today in your phone, things are hard to connect and share between different apps. They needs some container with common standard and specs to be shared with each other. Our Thinking of Mobile App#We think a dynamic, parallel development supported, standardized mobile app should be like this: |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| Pages: A whole mobile app should be divided into several mobile pages. Each mobile page has its own “URL”. Router: All the mobile pages above will be connected with router. And navigators or tab bars are just doing this job. Features: All kinds of APIs or services provided from the device. Every mobile page could use these features as they like. So before you build your mobile app, make sure how many mobile pages your mobile app has and what are they. How do they connect each other. Give each mobile page a URL. And sort out all the APIs and services your mobile app needs. Then create the pages and develop, debug and deploy them using Weex. Links Mobile page architecture If you have built a complete mobile app already and just want to using Weex to rebuild part of these pages, that’s absolutely no problem. Because Weex is just a SDK to build mobile pages which can coexist very well with other native views or hybrid pages. If the feature of WeexSDK is limited to your mobile app. You can extend your own components and modules. It requires some native development knowledge. But with our efforts on delivering more and more features, we believe this part of job will be getting smaller and smaller. Links Extend to iOS Extend to Android","type":"guide"},{"title":"Downgrade","path":"guide/advanced/downgrade.html","permalink":"https://weex.apache.org/guide/advanced/downgrade.html","text":"downgrade#Weex 2.0 downgrade change to module，please refer to downgrade","type":"guide"},{"title":"Asset Path","path":"guide/advanced/path.html","permalink":"https://weex.apache.org/guide/advanced/path.html","text":"Path#0.9 This article will cover uri (url) usage in Weex. Including using image/typeface resources, deal with relative uri and how to access local and packaged asset files. Schemes# LocalWeex SDK provide local scheme to access resources packaged with application, and of cource, it’s not working in the HTML5 runtime.Currently, developers can use this scheme with image and text’s font file location. In iOS, it’s always locate file in ‘bundle resources’. For example, a image component with local:///app_icon will load image file named ‘app_icon’ in bundle resouce, and font file work in the same way. In Android, image component will load from ‘drawable’ resource folder like ‘res/drawable-xxx’. But load font file is different, android framework can not load font file from ‘res’, so SDK will load it from asserts folder. HTTP/HTTPSIt’s working in the same way as in web, Weex support these at very beginning. FileUse file scheme to access local disk file. This scheme has its limitations: You would not hard coded a file url in source page. Because not matter it’s running in different platform(iOS, Android) or not, the content will be totally different in another device, which is depend to the specific device.So one possible case is getting the file url in runtime dynamically, which you can use it to diaplay a local disk image, or maybe upload it later. Relative URI#Like we do in HTML, weex process ‘relative URI’ in the same way. The relative URI, which start with /,.,..,//, will resolve by the bunle url.Means URL start with / will resolve to the root folder as bundle js file, . and .. will resolve to current and parent folder, and // will resolve to same scheme bundle js have. URI Adapter#All the above is the default implementation, developers can extend or override these their own by providing a ‘URI Adapter’. Same as the other adapters, Custom adapter should be set before Weex SDK is initializing.","type":"guide"},{"title":"Weex Page Architecture","path":"guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/guide/advanced/page-architecture.html","text":"Weex Page Architecture#A Weex page is a independent mobile page which includes UI, interaction logic, device power, lifecycle management etc. UI#Native DOM Model#Weex page has its HTML-like DOM model to manage UI. It will be decomposed into a DOM tree which consists of some DOM nodes. Links Weex Native DOM APIs Components#Weex supports many kinds of components. Some of them are content components such as text, image and videos. Some of them are container components such as div, list, scroller. Also there are some special components like slider, input, textarea, and switch. Links All components Weex supports Layout System#Weex use some CSS properties to layout every nodes in the DOM tree together. It includes: Box model: Describe the width, height, padding, margin and border of a component node. Flexbox: Describe the relations between different nodes with CSS Flexbox Spec. Supportting absolute, relative, fixed and sticky value of CSS position property. Features#Weex supports lots of device features through modules such as storage, navigation, modals etc. Each of them exposes some JS APIs. Links All modules Weex supports Lifecycle#Every Weex page has its lifecycle which is defined and implemented in WeexSDK. All Weex pages will go through the whole process, from being created and last to being destroyed.","type":"guide"},{"title":"Use Vuex and vue-router","path":"guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/guide/advanced/use-vuex-and-vue-router.html","text":"Using Vuex and vue-router#Vue.js has many peripheral technology products such as Vuex and vue-router, those libraries can also work well on Weex. NOTE: Weex is using native navigator to manage instance pages, the context of them are isolated. That means, Both Vuex and vue-router can only effect the single page, they can’t share state between different pages. Using Vuex# Official Vuex documents Vuex is a state management pattern + library for Vue.js applications. It’s also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. As a kind of state management library, Vuex is platform-independent, It also can be used in Weex. It also integrates with Vue’s official devtools extension to provide advanced features on web platform, such as zero-config time-travel debugging and state snapshot export / import. (web platform only) Using vue-router# Official vue-router documents Creating a Single-page Application with Vue.js + vue-router is dead simple. With Vue.js, you are already composing our application with components. When adding vue-router to the mix, all you need to do is map your components to the routes and let vue-router know where to render them. However, there are many differences between web and Android or iOS, some features of vue-router are limited in Weex. Router mode#vue-router provides three routing modes: hash: uses the URL hash for routing. Works in all Vue-supported browsers, including those that do not support HTML5 History API. (default) history: requires HTML5 History API and server config. See HTML5 History Mode. abstract: works in all JavaScript environments, e.g. server-side with Node.js. You can pass the mode parameter when creating a router: new Router(&#123; mode: 'abstract', // ...&#125;) Obviously, hash mode and history mode are only available on the web, and have no effect in Weex. In other words, you can only use abstract mode in Android and iOS. However, vue-router will automatically be forced into abstract mode if no browser API is present. So, just don’t set the mode option, or set it to abstract. Programmatic navigation#vue-router use &lt;router-link&gt; to create a navigation link, but in which, some features are based on the DOM events and it doesn’t work well in the native environment. In Weex, you must use the Programmatic Navigation to manage the router. Here is a basic example using &lt;router-link&gt;: &lt;!-- Can only be used on the web, it takes no effects on Android or iOS! --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; For native platforms, you have to use the router.push: &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"<cell>","path":"references/components/cell.html","permalink":"https://weex.apache.org/references/components/cell.html","text":"&lt;cell&gt;#Summary#This component must be used as a subcomponent of a list recycler waterfall component, which is for the performance optimizing for long list scrolling. Child Components#This type of component supports all kinds of weex component as its child components. Attributes#Notes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. keep-scroll-position {boolean}: v0.11+ List Whether to keep the last sliding position after inserting the Cell Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Notes: cell itself is a container, its layout info is managed by list, so specifying cell’s margin info will not work. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#please refer to List recycler waterfall","type":"references"},{"title":"<a>","path":"references/components/a.html","permalink":"https://weex.apache.org/references/components/a.html","text":"&lt;a&gt; is mainly used for navigation between weex pages。 Note: The behavior of &lt;a&gt; is similar to &lt;div&gt; except for the aspect mentioned in current page. Note: It’s forbidden to add text directly to &lt;a&gt;, use &lt;text&gt; to wrap your text instead. Basic Usage#Wrap the element navigating from with &lt;a&gt; &lt;a href=&quot;http://dotwe.org/raw/dist/a5e3760925ac3b9d68a3aa0cc0298857.bundle.wx&quot;&gt; &lt;text&gt;Jump&lt;/text&gt; &lt;/a&gt; Refer the demo. Attributes:# Attribute Type Value Default Value href String {URL} - - href#href defines the URL that current page will navigate. href must point to a weex page, the behavior of other case is undefined. Style#Support common styles. Events#Support common events click# Notes: The execution order of callback function of click and href is undefined. Do not use click event to do the preprocessing of href. Examples# Basic usage for &lt;a&gt; .","type":"references"},{"title":"<div>","path":"references/components/div.html","permalink":"https://weex.apache.org/references/components/div.html","text":"&lt;div&gt;#Summary#The most fundamental component which is a contianer to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child Components#This type of component supports all kinds of weex component as its child components including its own kind. Attributes#There is no specific attribute for this component. Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<image>","path":"references/components/image.html","permalink":"https://weex.apache.org/references/components/image.html","text":"&lt;image&gt; is used to display a single image in your interface. Note: &lt;img&gt; element which is usually used in HTML is not supported in Weex, you should use &lt;image&gt; instead. Note: Weex doesn’t have built-in image downloader, as download, cache, decompression features are complicated and some open source tools like SDWebImage handles it well, so please add native image adapter/handler before using &lt;image&gt;. See also: Android adapter and iOS handler. Basic Usage# Note: the style attributes of width and height must be specified, otherwise it won’t work. &lt;image style=\"width:500px;height:500px\" src=\"https://vuejs.org/images/logo.png\"&gt;&lt;/image&gt; See the example. Attributes# Attribute Type Value Default Value placeholder String {URL / Base64} - resize String conver / contain / stretch stretch src String {URL / Base64 } - Note: you can specify a relative URL for src and placeholder, relative URL will be rewritten to the to the actual resource URL (local or remote). See also: Path. placeholder#A URL value for placeholder image. It will be displayed when the image view is empty and will be replaced as soon as the ‘src’ image gets loaded.(Example) resize# contain: Scales the image as large as possible without cropping or stretching it. Remaining area within bounds is transparent (Example) cover: Scales the image as large as possible without stretching it. If the proportions of the image differ from the element, it is cropped either vertically or horizontally so that no empty space remains. (Example) stretch: Default value. Scales the content to fit the size of the element itself by changing the aspect ratio of the image if necessary. (Example) See also: background-size. src#The URL of the image to display. This attribute is mandatory for the &lt;image&gt; component. Supported Image Formats#Weex doesn’t give a list of image formats that must be supported, it mainly relies on the image adapter/handler you are using. For example, if you are using SDWebImage as the image adapter on iOS, you can use image formats like JPEG, PNG, GIF, WebP, etc. Component Methods#save v0.16.0+#Save &lt;image&gt; content to the local device or photo album, this operation may require device permission. Parameters: callback: {Function} A function which is called after the image has been saved to the local device or photo album. Callback parameters: result: {Object} Callback result whose properties are: success: {Boolean} A flag indicating whether the image has been saved completed. errorDesc: {String} A string containing the description of the error if image is not written successfully. Return value: null Note: You must add NSPhotoLibraryAddUsageDescription and NSPhotoLibraryAddUsageDescription (iOS 11) to enable the access permission of the iOS photo album. See also: Cocoa Keys. Use save Method#Add ref attribute (Vue.js Child Component Refs) on &lt;image&gt;: &lt;image ref=\"poster\" src=\"path/to/image.png\"&gt;&lt;/image&gt; Get the component reference and use the save method: const $image = this.$refs.poster$image.save(result =&gt; &#123; if (result.success) &#123; // Do something to hanlde success &#125; else &#123; console.log(result.errorDesc) // Do something to hanlde failure &#125;&#125;) Complete example goes here. Events#Support common events. load#load event handler will be called when the image is loaded. Event object: success: {Boolean} It shows that whether the image is loaded successfully. size: {Object} The loaded image size whose properties are: naturalWidth: {Number} The intrinsic width of image displayed on device, it will be zero if the specified image cannot be loaded correctly. naturalHeight: {Number} the intrinsic height of image displayed on device, it will be zero if the specified image cannot be loaded correctly. Handle load Event#Bind load event on &lt;image&gt;: &lt;image @load=\"onImageLoad\" src=\"path/to/image.png\"&gt;&lt;/image&gt; Add event handler: export default &#123; methods: &#123; onImageLoad (event) &#123; if (event.success) &#123; // Do something to hanlde success &#125; &#125; &#125;&#125; Complete example goes here. Styles#Support common styles. Usage Notes# Add image adapter/handler before using &lt;image&gt; The width and height in the styles of &lt;image&gt; must be specified. &lt;image&gt; can not have any nested child component. Examples# Base64 example Multi-layer images example Lazy load image example","type":"references"},{"title":"<indicator>","path":"references/components/indicator.html","permalink":"https://weex.apache.org/references/components/indicator.html","text":"&lt;indicator&gt;#Summary#The &lt;indicator&gt; component usually used to show an indicator effect, it must be used as a subcomponent of a slider component. Child Components#This component dosen not supports any child components. Attributes#There is no specific attribute for this component. Styles#Threr are some private styles for &lt;indicator&gt; : item-color: &lt;colors&gt; This style attribute sets the normal item, default is #CCCCCC. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item, default is #444444. item-size: &lt;length&gt; The radius of the indicator elements, default is 5px common styles: see common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#indicator demo","type":"references"},{"title":"<list>","path":"references/components/list.html","permalink":"https://weex.apache.org/references/components/list.html","text":"List#v0.6.1+ The List component, which inspired by Android RecyclerView, is a core component, and it provides the most popular features for using a list of items. which support vertical and horizontal list. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. list demolist demo Child Components#Notes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: true/false whether show the scroll bar or not, default value is true loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#onloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore event#loading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. load more demo","type":"references"},{"title":"<input>","path":"references/components/input.html","permalink":"https://weex.apache.org/references/components/input.html","text":"input#The weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child Components#This component does not support any child component. Attributes# type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, date, datetime, email, password, tel, time, url, number. each of which has the same meaning with \u001dW3C standard. value: the default value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. singleline: a boolean sttribute sets the properties of this field (lines, horizontally scrolling, transformation method) to be for a single-line input. lines: makes the input exactly this many lines tall. max-length: constrain edits not to make the length of the text greater than the specified length. max constrain the max date when type is date, format is yyyy-MM-dd min constrain the min date when type is date, format is yyyy-MM-dd maxlength: v0.7+ a number value to specify maxlength of input. return-key-type：v0.11the keybord returen key type support defalut, go, next, search, send, done. Styles# placeholder-color: the color of placeholder. Default value is ‘#999999’. Pseudo-classv0.9.5+: input component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles#check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events# input: the input evenr is fired when input content changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. return: the return key clicked. the object property of event: returnKeyType: return key Type of component value: component text value common events#check out common events support appear / disappear event. Methoads# focus() v0.9+ The focus() method is used to give focus to an input component and tigger soft keybord(if it can be focused). blur()v0.9+ The blur() method is used to remove focus from an input component and close soft keybord(if it has focus). setSelectionRange(selectionStart,selectionEnd) v0.11+set text selection range of input or textarea selectionStart {number}:set starting location text selection range selectionEnd {number}:set end location text selection range getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+get text selection range of input or textarea selectionStart {number}:get starting location text selection range selectionEnd {number}: get end location text selection range Notes#input does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object# for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; try it","type":"references"},{"title":"<refresh>","path":"references/components/refresh.html","permalink":"https://weex.apache.org/references/components/refresh.html","text":"&lt;refresh&gt;#v0.6.1+#The &lt;refresh&gt; Component provide a pulldown-refresh function for some special containers, its usage and attributes are similar to the &lt;loading&gt; Component. Note： To be rendered properly, the &lt;refresh&gt; Component must appear inside the special Component such as &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt;. Example: &lt;list&gt; &lt;refresh&gt; ... &lt;/refresh&gt; ...&lt;/list&gt; Complete example goes here Child Components# Any other components, like the &lt;text&gt; and &lt;image&gt; components, can be put inside the refresh component. &lt;loading-indicator&gt;: This is a dedicated component which provides a default refresh animation effect, can only be used inside the &lt;refresh&gt; or the &lt;loading&gt; components. Example: &lt;refresh&gt; &lt;text&gt;Refreshing&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/refresh&gt; Complete example goes here Attributes# Support all common attributes, check out common attributes Attribute Type Value Default Value display String show / hide show display# show：The refresh animation will be started if a &lt;loading-indicator&gt; is included in the refresh component. hide：Collapse the refresh view. It also hides the &lt;loading-indicator&gt; and stops the loading animation if there’s a &lt;loading-indicator&gt; included in the refresh component. Note： The visibility of &lt;refresh&gt; component can be controlled by display attribute with the value show and hide. A display=&quot;show&quot; should always be paired with a display=&quot;hide&quot; statement. Example: &lt;template&gt; &lt;list&gt; &lt;refresh @refresh=&quot;onrefresh&quot; :display=&quot;refreshing ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/refresh&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onrefresh (event) &#123; this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; Complete example goes here Styles# Please check out the common styles Events#refresh# Triggered when the scroller or list is pulled down. pullingdown v0.6.1+# Triggered when the scroller or list is pulled down. The attributes dy, pullingDistance, viewHeight and type are accessible from the event object : dy : The offset between two scroll actions pullingDistance : The distance of pulling viewHeight : The height of refreshView type : “pullingdown” constant string type for this event Example: &lt;scroller&gt; &lt;refresh @refresh=&quot;onrefresh&quot; @pullingdown=&quot;onpullingdown&quot;&gt; ... &lt;/refresh&gt; ...&lt;/scroller&gt;&lt;script&gt; export default &#123; methods: &#123; onrefresh (event) &#123; ... &#125;, onpullingdown (event) &#123; console.log(&quot;dy: &quot; + event.dy) console.log(&quot;pullingDistance: &quot; + event.pullingDistance) console.log(&quot;viewHeight: &quot; + event.viewHeight) console.log(&quot;type: &quot; + type) &#125; &#125; &#125;&lt;/script&gt; Complete example goes here Example# Complete example goes here","type":"references"},{"title":"<loading>","path":"references/components/loading.html","permalink":"https://weex.apache.org/references/components/loading.html","text":"&lt;loading&gt;#v0.6.1+#The &lt;loading&gt; Component provide a pullup to loading function for some special containers, its usage and attributes are similar to the &lt;refresh&gt; Component. Note： To be rendered properly, the &lt;loading&gt; Component must appear inside the special Component such as &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt;. Example: &lt;list&gt; ... ... &lt;loading&gt; ... &lt;/loading&gt;&lt;/list&gt; Complete example goes here Child Components# Any other components, like the &lt;text&gt; and &lt;image&gt; components, can be put inside the loading component. &lt;loading-indicator&gt;: This is a dedicated component which provides a default loading animation effect, can only be used inside the &lt;refresh&gt; or the &lt;loading&gt; components. Example: &lt;loading&gt; &lt;text&gt;Loading&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/loading&gt; Complete example goes here Attributes# Support all common attributes, check out common attributes Attribute Type Value Default Value display String show / hide show display# show：The loading animation will be started if a &lt;loading-indicator&gt; is included in the loading component. hide：Collapse the loading view. It also hides the &lt;loading-indicator&gt; and stops the loading animation if there’s a &lt;loading-indicator&gt; included in the loading component. Note： The visibility of &lt;loading&gt; component can be controlled by display attribute with the value show and hide. A display=&quot;show&quot; should always be paired with a display=&quot;hide&quot; statement. Example: &lt;template&gt; &lt;list&gt; ... ... &lt;loading @loading=&quot;onloading&quot; :display=&quot;loadinging ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/loading&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onloading (event) &#123; this.loadinging = true setTimeout(() =&gt; &#123; this.loadinging = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; Complete example goes here Styles# Please check out the common styles Events#onloading# Triggered when the scroller or list is pulled up. Complete example goes here Example# Complete example goes here","type":"references"},{"title":"<slider>","path":"references/components/slider.html","permalink":"https://weex.apache.org/references/components/slider.html","text":"&lt;slider&gt;#Summary#A slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child Components#It supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes# auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: . This value determines the index of current shown slide. The default value is 0. offset-x-accuracy {float}：set the scroll event trigger precision, precision value represents the rolling distance of a page width ratio. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. scroll 0.11+：this event is fired when scrolling. The current offsetXRatio value is given in this event callback. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<scroller>","path":"references/components/scroller.html","permalink":"https://weex.apache.org/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ Scroller is a component which can have multiple child components in one column. It supports both direcitons. If the content size of child components exceeds the frame of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. Child Components#Scroller supports all kinds of components, such as div, text, etc.There are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: &lt;boolean&gt; true | false, default value is true. This attribute indicates whether show the scroll bar or not. scroll-direction: &lt;string&gt; the scroll direction of component, horizontal or vertical. scroll-direction defines the scrollable axis of scroller and flex-direction defines the layout axis of scroller. scroll-direction and flex-direction must be set to the same direction, otherwise, undefined behavior may happen. Default value for scroll-direction is vertical, and for flex-direction is row . Use scroll-direction:horizontal and flex-direction: row when a horizontal layout and scrollable scroller is expected. Use scroll-direction:vertical and flex-direction: column when a vertical layout and scrollable scroller is expected. But those two values are default, if you don’t set them, it also works fine. loadmoreoffset : &lt;number&gt; default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom. e.g. A list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : &lt;number&gt; default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy：&lt;number&gt; default value is 0, the vertical offset distance required to trigger the scroll event. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events support loadmore event. The loadmore event should be used in concert with loadmoreoffset. If the view has less than loadmoreoffset to scroll down, the event will be triggered.See details in example. support scroll event 0.12+ .The scroll should be used in concert with offset-accuracy. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in example. support scrollstart and scrollend event 0.17+ .These events are fired when the list begins or ends scrolling.The current contentSize and contentOffset value are given in this event callback. See details in example. Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested list/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<switch>","path":"references/components/switch.html","permalink":"https://weex.apache.org/references/components/switch.html","text":"v0.6.1+ &lt;switch&gt; is a checkbox-like UI component. Note: The appearance of switch component is a bit of different in three ends (iOS, Android, Web) in consideration of different platform styles. Android Web iOS Note: Layout style attributes listed below such as width, height, margin are not supported. Basic Usage#&lt;switch&gt;&lt;/switch&gt; See the example. Attributes# Attribute Type Value Default Value checked Boolean true / false false disabled Boolean true / false false checked#Indicates this component’s status is set to true or false. disabled#Indicates this component is not available for interaction. Component Methods#None. Events# appear / disappear event. check out common events click / longpress: check out common events change: check out common events Parameters of events’ object for onchange event:# value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event. Styles# Notes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxx padding and padding-xxx border and border-xxx Notes: If the container of &lt;switch&gt; is not set to align-items:flex-start, the switch in android will be stretched. common styles: check out common styles for components Usage Notes# The width and height in the styles of &lt;switch&gt; won’t effect the component’s apparence and layout. &lt;switch&gt; can not have any nested child component. Examples# Simple Switch Switch List","type":"references"},{"title":"<text>","path":"references/components/text.html","permalink":"https://weex.apache.org/references/components/text.html","text":"The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Note: This component supports no child components. Attributes# value(string): text value of this component. This is equal to the content of ‘text’. var textComponent = this.$el(&quot;textid&quot;); this.text = textComponent.attr.value; Styles# Support common styles for components lines: specify the text lines. Default value is 0 for unlimited. Support text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. Events#Support common events Custom Typeface#support:v0.12.0 support ttf and woff font format to custom your text, call addRule in dom module to build your own font-family, we suggest that you call addRule in beforeCreate. Examples# \bBasic usage for &lt;text&gt;. Usage for custom typeface.","type":"references"},{"title":"<textarea>","path":"references/components/textarea.html","permalink":"https://weex.apache.org/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ Summary#The weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child Components#This component supports no child components. attributes# value: &lt;string&gt; the value of the control. placeholder: &lt;string&gt; a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: &lt;boolean&gt; a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: &lt;boolean&gt; a boolean attribute lets you specify that a form control should have input focus when the page loads. rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. Styles#Pseudo-classv0.9.5+: textarea component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events# input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object# for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"references/components/video.html","permalink":"https://weex.apache.org/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ The video component can be used to embed video content in a weex page. Child Components# text is the only valid type of child component. Attributes# src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed. example#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<waterfall>","path":"references/components/waterfall.html","permalink":"https://weex.apache.org/references/components/waterfall.html","text":"waterfall#v0.11.0+ A component providing waterfall layout. Child Components#Notes: The waterfall now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell: presents the content for a single data item in waterfall header: components that need to stretch across multiple columns. It can be sticky by using css position. Attributes# column-width : This property describes the width of columns in waterfall elements. auto: means that the column width will be determined by other properties(e.g., column-count, if it has a non-auto value). &lt;length&gt;: describes the optimal column width. The actual column width may be wider (to fill the available space), or narrower (only if the available space is smaller than the specified column width). Specified values must be greater than 0. column-count:This property describes the number of columns of a multicol element. auto: means that the number of columns will be determined by other properties (e.g., column-width, if it has a non-auto value). &lt;integer&gt;: describes the optimal number of columns into which the content of the element will be flowed. Values must be greater than 0. If both column-width and column-count have non-auto values, the integer value describes the maximum number of columns. column-gap:sets the gap between columns. if normal is specified, the gap will be 32. To see other attributes, please checkout List Component Attributes Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All subcomponents in waterfall support the scrollToElement API in dom module Example#see playground waterfall example","type":"references"},{"title":"<web>","path":"references/components/web.html","permalink":"https://weex.apache.org/references/components/web.html","text":"v0.5+ &lt;web&gt; is used to display web content that specified by src attribute in weex page. You also can use webview module to control WebView behavior such as goBack, goForward and reload, See webview module for more information. Basic Usage# Note: &lt;web&gt; does not support any nested child components, and must specific width and height in style attribute, otherwise it won’t work. &lt;web src=\"https://vuejs.org\"&gt;&lt;/web&gt; See the example. Attributes# Attribute Type Value Default Value src String {URL} - src#A URL value for web content to be loaded. You can specify a URL which is relative to bundle URL, it will be rewritten to the real resource URL (local or remote). See also: Path. Events#Only support appear and disappear event in common events. pagestart#pagestart event handler will be called when the web content is start loading. Event object: url: {String} URL of current web content. pagefinish#pagefinish event handler will be called when the web content is loaded. Event object: url: {String} URL of current web content. canGoBack: {Boolean} Can current web content go back. canGoForward: {Boolean} Can current web content go forward. title: {String} Title of current web content (iOS platform only). error#error event handler will be called when the web content loaded failed. receivedtitle#receivedtitle event handler will be called when the title of web content had changed (Android platform only). Event object: url: {String} URL of current web content. Handle &lt;web&gt; Events#Bind events on &lt;web&gt;: &lt;web @pagestart=\"onPageStart\" @pagefinish=\"onPageFinish\" @error=\"onError\" src=\"https://vuejs.org\"&gt;&lt;/web&gt; Add event handler: export default &#123; methods: &#123; onPageStart (event) &#123; // page start load &#125;, onPageFinish (event) &#123; // page finish load &#125;, onError (event) &#123; // page load error &#125;, &#125;&#125; See the example. Styles#Support common styles. Usage Notes# The width and height in the styles of &lt;web&gt; must be specified. &lt;web&gt; can not have any nested child component. You can use webview module to control &lt;web&gt; component, see the example. Examples# Browser example","type":"references"},{"title":"animation","path":"references/modules/animation.html","permalink":"https://weex.apache.org/references/modules/animation.html","text":"Animation#Overview#The animation module is used to perform animation on components. JS-Animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component with Javascript. For example, if you have a image component, you can move, rotate, grow, or shrink it by animation. Note: Now,Weex only support use animation in Javascript. CSS Animation is different from this,we will soon support CSS Animation. Basic Usage#animation.transition(el, options, callback)#animation.transition(ref1, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(250px, 100px)', &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) Attributes#el#An element that will be animated. For example , specify the el attribute for the element you want to animated as element, so you can get this element by calling this.refs.element. options# styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value width The width applied to the component after the animation finished. length none height The height applied to the component after the animation finished. length none backgroundColor The background color applied to the component after the animation finished. string none opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center transform Transform function to be applied to the element. The properties in the following table are supported object none transform also have many parameters,please see the table below. name description value type default value translate/translateX/translateY Specifies the location of which the element will be translated to. pixel or percent none rotate/rotateX v0.14+ /rotateY v0.14+ Specifies the angle of which the element will be rotated, the unit is degree. number none perspective v0.16+ The distance between the z=0 plane and the user in order to give to the 3D-positioned element some perspective. Supported for Android 4.1 and above. number positive infinity scale/scaleX/scaleY Stretch or shrink the element. number none duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. needLayout(boolean)：Whether or not the layout animation occurs when animation is executed，default value is false timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description linear Specifies a transition effect with the same speed from start to end ease Specifies a transition effect with a slower and slower speed ease-in Specifies a transition effect with a slow start ease-out Specifies a transition effect with a slow end ease-in-out Specifies a transition effect with a slow start and end cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. callback#Callback which is a function called after the completion of animation. In iOS platform, you can use function to get animation processing’s information. Note: after WeexSDK0.16.0, in iOS platform can get animation’s message about completion, there are two types of parameters with result, is Successand Fail, Android can not support until now. Example# animation demo","type":"references"},{"title":"clipboard","path":"references/modules/clipboard.html","permalink":"https://weex.apache.org/references/modules/clipboard.html","text":"clipboard#v0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution# only support text. only works on Android and iOS. NOT works for html5, for web security reason. API#getString(callback)#reads from clipboard. Arguments#callback(function): the callback function after executing this action. data is the return value. setString(text)#sets the text to clipboard, having the same effect as copying manually. Arguments#text(string): the text copied to clipboard. Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"references/modules/dom.html","permalink":"https://weex.apache.org/references/modules/dom.html","text":"Dom#Overview#The dom module is used to manipulate the components in weex pages. You can use these APIs to get a component’s bounding rect in the page, or scroll a list to some specific component, or add a font-face rule to the page and so on. Note: The addRule method is currently used only with font-face supportability. API#scrollToElement(ref, options)#Scroll the scrollable component to the referenced component. This API should only be used in the children components of a scrollable component, such as in a &lt;scroller&gt; or &lt;list&gt; component. NOTE: You can use weex.requireModule(&#39;dom&#39;) to requrie the dom module, and use weex.requireModule(&#39;dom&#39;).scrollToElement to call this API. Arguments# ref(Node): the referenced component who is meant to scroll into the view. options(object): offset(number): An space on top of the ref component, which is also scrolling down to the visual viewport. Default is 0. animated (bool): 0.10+ Indicates whether a scroll animation should be played. If set to false, the ref component will jump into the view without any transition animation. Default is true. Example#Scroll To Floor getComponentRect(ref, callback) v0.9.4+#support: &gt;=0.9.4 You can get the bounding rect of the referenced component using this API. An example callback result should be like: &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; If you want to get the bounding rect of outside viewport of the weex container, you can specify the ref as a literal string &#39;viewport&#39;, like getComponentRect(&#39;viewport&#39;, callback). Example#get box’s rect addRule(type, contentObject) v0.12.0+#support: &gt;=0.12.0 You can add certain rules for dom throught this API. Now we only support fontFace for building a custom font-family. You can use the built font-family in your project for text component directly. fontFace#const domModule = weex.requireModule('dom')domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;); Example#add rule fontface","type":"references"},{"title":"globalEvent","path":"references/modules/globalevent.html","permalink":"https://weex.apache.org/references/modules/globalevent.html","text":"globalEvent#v0.8+ Summary#globalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removeEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global events#API development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) Example#Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\", params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#register global event. Arguments# eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#remove global event Arguments# eventName(string): You no longer need to listen for event names. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"meta","path":"references/modules/meta.html","permalink":"https://weex.apache.org/references/modules/meta.html","text":"meta#The meta module can be used to declare meta information for a single page, such as the viewport of the container. API#setViewport(options)#0.10.0+ The default width (viewport) of Weex container is 750px. The setViewport method can change the viewport of the page and only takes effect on the current page. Notice: The viewport must be set before the page rendering starts. In other words, the setViewport method can only be used in the entry file, and before the new Vue (...) statement. If it’s used in the component, the code is executed only when the component is being rendered, meanwhile, the page is already in the rendering process, set the viewport will not take effect again. it is only in the rendering of the components will be implemented The corresponding code, Parameters#Referance: W3C Spec CSS Device Adaptation. options: viewport configuration width: Number or &quot;device-width&quot; or &quot;device-height&quot;. height: Number or &quot;device-width&quot; or &quot;device-height&quot;. The default unit of the width and height is px, other units are not supported. Example#The entry file: // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// The width of the viewport is set to 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) After configuring the width of the viewport to 640 in the entry.js, all the components in the current page will take 640px as full screen width. Example component: &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; Try it. (The http://dotwe.org doesn’t support to configure the entry file currently.) Referance: Set up development environment.","type":"references"},{"title":"navigator","path":"references/modules/navigator.html","permalink":"https://weex.apache.org/references/modules/navigator.html","text":"Navigator#v0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can specify whether to apply animation or not during the transition. API#push(options, callback)#push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. url(stirng): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. pop(options, callback)#pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"push\"&gt;Push&lt;/text&gt; &lt;text class=\"button\" @click=\"pop\"&gt;Pop&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; push (event) &#123; var bundleUrl = weex.config.bundleUrl; navigator.push(&#123; url: bundleUrl, animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125;, pop (event) &#123; navigator.pop(&#123; animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"modal","path":"references/modules/modal.html","permalink":"https://weex.apache.org/references/modules/modal.html","text":"modal#Weex provides a series of message boxes: toast, alert, confirm and prompt. API#toast(options)#A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments# options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. For Android: If the duration is longer than 3, it will use a system defined variable called LONG, otherwise it will use another variable called SHORT For iOS: It will show the toast during the specified time. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.toast(&#123; message: &apos;This is a toast&apos;, duration: 0.3&#125;) alert(options, callback)#An alert box is often used if you want to make sure information comes through to the user.When an alert box pops up, the user will have to click “OK” to proceed. Arguments# options (object): alert box options. message (string): the text message that the alert shows. okTitle (string): the text of positive button, default is ‘OK’. callback (function): callback when complete.This method has a callback function whose arguments will be: result (string): the title text of the confirm button that clicked by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.alert(&#123; message: &apos;This is a alert&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;alert callback&apos;, value)&#125;) confirm(options, callback)#A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments# options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.confirm(&#123; message: &apos;Do you confirm ?&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;confirm callback&apos;, value)&#125;) prompt(options, callback)#A prompt box is often used if you want the user to input a value before entering a page.When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. Arguments# options (object): some options. message (string): the message that the prompt shows. okTitle (string): the title text of confirm button, default is ‘OK’. cancelTitle (string): the title text of cancel button, default is ‘Cancel’. callback (function): callback when complete.This method has a callback function whose arguments will be: ret (object): the argument will be a object, which has attributes result and data, like { result: &#39;OK&#39;, data: &#39;hello world&#39; } result (string): the title of the button that clicked by user. data (string): the value of the text that entered by user. Basic Usage#var modal = weex.requireModule(&apos;modal&apos;)modal.prompt(&#123; message: &apos;This is a prompt&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;prompt callback&apos;, value)&#125;) Example#Modal demo","type":"references"},{"title":"picker","path":"references/modules/picker.html","permalink":"https://weex.apache.org/references/modules/picker.html","text":"picker#v0.9+ Summary#A series of stream api. It provides function: pick data,pick date,pick time API#pick(options, callback[options])#pick data(single column) Arguments# options {Object}:pick options index {number}:default selected row items {array}:picker’s data callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {number}:the selected index,it exists when result is success. pickDate(options, callback[options])#pick date Arguments# options {Object}:pick date options value {string}:Required，date picker selected value by default，date’s form is yyyy-MM-dd max {string}:optional，date’s max value min {string}:optional，date’s min value callback {function (ret)}：the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is yyyy-MM-dd ,it exists when result is success. pickTime(options, callback[options])#pick time Arguments# options {Object}:pick time options value {string}:required，the form of value is HH:mm callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter： result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is HH:mm,it exists when result is success. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"storage","path":"references/modules/storage.html","permalink":"https://weex.apache.org/references/modules/storage.html","text":"storage#v0.7+ Summary#storage is a series of apis, allowing you to for example add, modify or delete stored data items. API#setItem(key, value, callback)#When passed a key name and value, will add that key to the storage,or update that key’s value if it already exists. Arguments# key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. getItem(key, callback)#When passed a key name, will return that key’s value. Arguments# key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. removeItem(key, callback)#When passed a key name, will remove that key from the storage. Arguments# key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Example#var storage = weex.requireModule('storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)#Returns an integer representing the number of data items stored in the Storage object. Arguments# callback(object): the callback function after executing this action. getAllKeys(callback)#Returns an array that contains all keys stored in Storage object. Arguments# callback(object): the callback function after executing this action. Example#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"webview","path":"references/modules/webview.html","permalink":"https://weex.apache.org/references/modules/webview.html","text":"webview module provides a series of web operation API like goBack, goForward, and reload. Usually used with the &lt;web&gt; component. API#goBack(webElement)#Goes to the previous page in WebView’s session history. Arguments webElement(web): the element of the &lt;web&gt; component. goForward(webElement)#Goes to the next page in WebView’s session history. Arguments webElement(web): the element of the &lt;web&gt; component. reload(webElement)#Reloads the current web page. Arguments webElement(web): the element of the &lt;web&gt; component. Examples# Simple useage: var webElement = this.$el('webview');var webview = weex.requireModule('webview');webview.goBack(webElement.ref);webview.goForward(webElement.ref);webview.reload(webElement.ref); Browser example","type":"references"},{"title":"webSocket","path":"references/modules/websocket.html","permalink":"https://weex.apache.org/references/modules/websocket.html","text":"webSocket#v0.12+ Summary#WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user’s H5/iOS/android and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply Notes:# iOS and h5 provide webSocket default handle. if you use webSocket in android environment . you should provide custom adapter implementation,source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; refer: weex playground API#WebSocket(url, protocol)#create websocket Arguments# url {string}:The URL to which to connect; protocol {string}:the websocket protocol send(data)#Transmits data to the server over the WebSocket connection Arguments# data {string}:A text string to send to the server. close(code,reason)#Closes the WebSocket connection or connection attempt, if any. If the connection is already CLOSED, this method does nothing. Arguments# code {number}: the status code explaining why the connection is being closed. reason {string}:a string explaining why the connection is closing onopen(options)#An event listener to be called when the WebSocket connection’s readyState changes to OPEN; this indicates that the connection is ready to send and receive data. Arguments# options {object}:an empty object onmessage(options)#An event listener to be called when a message is received from the server Arguments# options {object}:the server message options data {string}: The listener received message onclose(options)#An event listener to be called when the WebSocket connection’s readyState changes to CLOSED Arguments# options {object}:the CloseEvent is sent to clients using WebSockets when the connection is closed code {number}: Returns an unsigned short containing the close code send by the server reason {string}: Returns a string indicating the reason the server closed the connection wasClean {boolen}: Returns a Boolean that Indicates whether or not the connection was cleanly closed. onerror(options)#An event listener to be called when an error occurs. Arguments# options {object}:the error event data {string}: The listener received error data Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"stream","path":"references/modules/stream.html","permalink":"https://weex.apache.org/references/modules/stream.html","text":"stream#A series of stream api. It provides a network request. API#fetch(options, callback,progressCallback)#Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): response type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Note# Default Content-Type is ‘application/x-www-form-urlencoded’. (The type specified in fetch is the response type!) You need to set the Content-Type header to ‘application/json’ manually if you want to post the json body. Example#stream demo","type":"references"},{"title":"Weex 页面结构","path":"cn/guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/page-architecture.html","text":"Weex 页面结构#一个 Weex 页面就是一个相对独立解耦的移动应用界面，它不仅包括了界面展示、更包含了逻辑处理、设备能力使用、生命周期管理等部分。 界面#DOM 模型#Weex 页面通过类似 HTML DOM 的方式管理界面，首先页面会被分解为一个 DOM 树，，每个 DOM 结点都代表了一个相对独立的 native 视图的单元。然后不同的视图单元之间通过树形结构组合在了一起，构成一个完整的页面。 相关链接 Weex Native DOM APIs 组件#Weex 支持文字、图片、视频等内容型组件，也支持 div、list、scroller 等容器型组件，还包括 slider、input、textarea、switch 等多种特殊的组件。Weex 的界面就是由这些组件以 DOM 树的方式构建出来的。 相关链接 Weex 组件列表 布局系统#Weex 页面中的组件会按照一定的布局规范来进行排布，我们这里提供了 CSS 中的盒模型、flexbox 和 绝对/相对/固定/吸附布局这三大块布局模型。 盒模型：通过宽、高、边框、内外边距、边框等 CSS 属性描述一个组件本身的尺寸。 flexbox：通过 CSS 3 Flexbox 布局规范定义和描述组件之间的空间分布情况。 position：支持 CSS position 属性中的 absolute, relative, fixed, sticky 位置类型，其中 relative 是默认值。 功能#Weex 提供了非常丰富的系统功能 API，包括弹出存储、网络、导航、弹对话框和 toast 等，开发者可以在 Weex 页面通过获取一个 native module 的方式引入并调用这些客户端功能 API。 相关链接 Weex 模块列表 生命周期#每个 Weex 页面都有其自身的生命周期，页面从开始被创建到最后被销毁，会经历到整个过程。这是通过对 Weex 页面的创建和销毁，在路由中通过 SDK 自行定义并实现的。","type":"guide"},{"title":"降级方案","path":"cn/guide/advanced/downgrade.html","permalink":"https://weex.apache.org/cn/guide/advanced/downgrade.html","text":"降级方案#Weex 2.0 降级方案改成模块的形式支持，具体请参考downgrade","type":"guide"},{"title":"构建完整移动应用","path":"cn/guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/app-architecture.html","text":"用 Weex 构建移动应用#今天的移动应用#这里谈一谈 Weex 对移动应用的理解。 移动应用需要支撑并行研发#如今移动应用的开发需要并行研发的能力，当一个移动应用发展到一定规模的时候，能否支撑大规模的并行研发就成为了一件非常关键而又重要的事情。否则很容易变成工程瓶颈。 移动应用需要动态性#如今移动应用不论从研发节奏、部署的灵活性和时效性、包大小、还是从研发到发布再到反馈的迭代周期上，都和移动互联网的发展速度极不相符。移动应用需要更简单轻量的研发模型，需要摆脱版本部署和分发的笨重过程。 移动应用需要开放互联#如今移动应用的内容和信息都是相互孤立的，应用之间的交流变得非常复杂和困难，也缺乏一定的标准和规范化的容器来承载。 整体结构设计#我们认为一个具有高并行研发能力、动态化和标准化规范化的移动应用应该由以下几个方面构成： |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| 页面：首先移动应用应该可以被拆解成若干个页面，每个页面相对解耦独立，同时每个页面都有一个 URL 进行唯一标识。 路由：这些页面将会通过路由机制有机的串联起来，页面之间的关系是通过路由来进行调度的。常见的移动应用路由包括导航栏、tab 切换等。 设备能力：以各种 API 或服务的方式提供出来，供页面自由使用。 这样的话，在构建一个完整的移动应用之前，先确定你的应用有多少页面，每个页面分别是什么 URL，页面之间的关联和跳转逻辑是怎样的，然后梳理整个移动应用需要的所有 API 和服务。 然后通过 Weex 创建不同的页面，并分别进行开发、调试和发布。 相关链接 页面结构 如果你已经有一个做好的移动应用，只想用 Weex 开发其中的一部分页面甚至仅仅其中的一两个页面，这对 Weex 来说完全不是问题。Weex 只是一个 SDK，对整体的移动应用架构不会产生任何侵入性。并且完全可以和纯 native 界面或 hybrid 页面共存。 如果需要 WeexSDK 额外的组件、模块或其它功能，可以通过 Weex 的扩展机制进行扩展。这部分工作需要 native 的研发知识，但是随着 Weex 组件和模块的丰富以及业务迭代的深入，这部分成本会承下降和收敛的趋势。 相关链接 如何扩展 iOS 如何扩展 Android","type":"guide"},{"title":"资源路径","path":"cn/guide/advanced/path.html","permalink":"https://weex.apache.org/cn/guide/advanced/path.html","text":"Path#v0.9+ 本文将介绍 Weex 中 uri(url) 的用法。包括使用图像、字体等资源，处理相对路径以及如何访问本地及打包的资源文件。 Schemes# 本地资源 Weex SDK 提供 local scheme 来访问打包在应用程序中的资源，此 scheme 无法在 H5 环境下使用。目前，开发者可以在 image 组件和字体文件中使用本地资源。 在 iOS 中，Weex 会在 bundle resources 中查找。例如，image 组件的 src 属性为 local:///app_icon&#39;， Weex 会加载 bundle resouce 中名为 app_icon 的图像资源，而字体文件也以相同的方式工作。 在 Android 中，image 组件将从 drawable 资源文件夹加载，如 res/drawable-xxx。但加载字体文件是不同的，Android 框架无法从 res 加载字体文件，因此 SDK 将从 asserts 文件夹加载它。 HTTP/HTTPS 它的工作方式与 web 相同，Weex 一直支持这种方式。 File 使用 file scheme 访问本地磁盘文件。这个方案有其局限性：你不应该在源页面中硬编码文件 url。因为不管它是否在不同的平台（iOS，Android）上运行，内容将在另一个设备上完全不同，这取决于具体的设备。 所以一种可行的方案是在运行时动态获取文件 url，你可以使用它来显示本地磁盘的图像，或者稍后上传它。 相对路径#与我们在 HTML 中的用法类似，Weex 以相同的方式处理相对路径。以/、.、..、// 开头的相对 URI 将相对于 bunle url 解析。 这意味着， 一个以 / 开头的路径将是相对于 JS Bundle 文件的根文件夹。. 则是当前文件夹，.. 是父文件夹。 // 则被解析为与 JS Bundle 相同的 scheme。 URI Adapter#以上所有是默认实现，开发者可以通过提供一个 URI Adapter 来扩展或覆盖默认实现。与其他 Adapter 相同，应在 Weex SDK 初始化之前设置自定义 Adapter。","type":"guide"},{"title":"使用 Vuex 和 vue-router","path":"cn/guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/cn/guide/advanced/use-vuex-and-vue-router.html","text":"使用 Vuex 和 vue-router#Vue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 注意： Weex 使用原生的 navigator 来管理页面实例，多个实例之间的状态是隔离的。也就是说，Vuex 和 vue-router 只能作用于当前一个页面，无法在多个页面间共享状态。 使用 Vuex# Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具库，可以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 由于在 Vuex 本身就是平台无关的，有较强的移植能力，完全可以在 Weex 中正常地使用 Vuex。 Vuex 也集成到了其官方调试工具 devtools extension中，提供了诸如 time-travel 调试、状态快照导入导出等高级调试功能。这些工具在 Web 平台中可以一如既往地工作。 使用 vue-router#vue-router 是专为 Vue.js 开发的便于实现单页应用的工具库，能够以声明式的方法编写页面的导航和跳转信息。 由于 Weex 的运行环境不只是浏览器，通常是以移动端原生环境为主，然而在 Android 和 iOS 中都没有浏览器的 History API，也不存在 DOM，因此如果想在 Weex 环境中使用 vue-router ，有些功能受到了限制，使用时应该注意。 路由模式#vue-router 提供了三种运行模式： hash: 使用 URL hash 值来作路由。默认模式。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 配置方法是在定义路由时，传递 mode 属性： new Router(&#123; mode: 'abstract', // ...&#125;) 从三种模式的介绍中也可以看出来，Weex 环境中只支持使用 abstract 模式。不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以在使用时只要不写 mode 配置即可。默认 vue-router 会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 编程式导航#vue-router 中使用 &lt;router-link&gt; 创建导航链接，不过在其中使用了基于 DOM 事件的一些特性，在 Weex 原生环境中并不能很好的工作。在 Weex 中，你必须使用编程式导航来编写页面跳转逻辑。 编程式导航其实就是通过主动调用 router 实例上的 push 方法实现跳转。 使用 &lt;router-link&gt; 的代码示例： &lt;!-- 只能在 Web 中使用，Native 环境不支持！ --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在 Weex 中，需要写成这个样子： &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"<a>","path":"cn/references/components/a.html","permalink":"https://weex.apache.org/cn/references/components/a.html","text":"&lt;a&gt; 用于实现页面间的跳转。 注意： 除了本文档中注明的特性，\b&lt;a&gt;\b 的表现同 &lt;div&gt; 一致。 注意： 不能要 &lt;a&gt; 中直接添加\b匿名文本，请用\b &lt;text&gt; 包裹文本。 基本用法#用 \b&lt;a&gt; \b将待跳转的元素包裹起来即可。 &lt;a href=&quot;http://dotwe.org/raw/dist/a5e3760925ac3b9d68a3aa0cc0298857.bundle.wx&quot;&gt; &lt;text&gt;Jump&lt;/text&gt; &lt;/a&gt; 参见示例。 属性# 属性名 类型 值 默认值 href String {URL} - - href#待跳转的页面URL，待跳转页面需要是一个Weex页面。如果\b待跳转页面是一个普通HTML\b\b，\b这会是一个未定义行为。 样式#&lt;a&gt; 支持通用样式。 事件#&lt;a&gt;支持 通用事件. click# 注意： click 事件的回调函数和 href 跳转的执行顺序未被定义。不要使用 click 来进行 href 跳转前的逻辑处理。 示例# &lt;a&gt; 的基本用法。","type":"references"},{"title":"<cell>","path":"cn/references/components/cell.html","permalink":"https://weex.apache.org/cn/references/components/cell.html","text":"&lt;cell&gt;#用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; &lt;recycler&gt; &lt;waterfall.&gt;组件的子组件, 这是为了优化滚动时的性能。 子组件#支持所有 Weex 的组件作为它的子组件。 属性# keep-scroll-position {boolean}: v0.11+ List 插入数据后是否保持上次滚动的位置 样式#注意： 由于 &lt;cell&gt; 本身是一个容器，其布局由 &lt;list&gt; 进行管理，你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应，指定 margin 样式也不起作用。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#cell 示例","type":"references"},{"title":"<div>","path":"cn/references/components/div.html","permalink":"https://weex.apache.org/cn/references/components/div.html","text":"&lt;div&gt;#&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70px; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件#&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式#&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件#&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束# 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 在 native 中不可滚动，即使显式设置高度也一样。 错误示例 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<image>","path":"cn/references/components/image.html","permalink":"https://weex.apache.org/cn/references/components/image.html","text":"&lt;image&gt; 用于在界面中显示单个图片。 注意：在HTML中通常使用的 &lt;img&gt; 标签在 Weex 中不支持，你应该使用&lt;image&gt; 。 注意： Weex 没有内置的图片下载器，因为相关的下载、缓存、解码机制非常复杂，一些开源的工具如 SDWebImage 已经处理得很好， 所以在使用 &lt;image&gt; 之前，请在 native 侧先接入相应的 adapter 或者 handler。 参见: Android adapter 和 iOS handler。 基本用法# 注意： 必须指定样式中的宽度和高度，否则无法工作。 &lt;image style=\"width:500px;height:500px\" src=\"https://vuejs.org/images/logo.png\"&gt;&lt;/image&gt; 参见示例。 属性# 属性名 类型 值 默认值 placeholder String {URL / Base64} - resize String conver / contain / stretch stretch src String {URL / Base64 } - 注意：您可以指定一个相对 bundle URL 的相对路径，相对路径将被重写为绝对资源路径(本地或远程)。参见: 资源路径。 placeholder#占位图的 URL，当由 src 表示的图片下载完成并展示后将被删除。 (示例) resize# contain：缩放图片以完全装入&lt;image&gt;区域，可能背景区部分空白。 (示例) cover：缩放图片以完全覆盖&lt;image&gt;区域，可能图片部分看不见。 (示例) stretch：默认值. 按照&lt;image&gt;区域的宽高比例缩放图片。(示例) 参见: background-size. src#要显示图片的 URL，该属性是 &lt;image&gt; 组件的强制属性。 支持的图片格式#Weex没有提供必须支持的图片格式列表，主要依赖于你正在使用的图片 adapter 或者 handler。例如，如果你使用 SDWebImage 作为iOS上的图片 handler，你可以使用像 JPEG、PNG、GIF、WebP 等图片格式。 Component 方法#save v0.16.0+#保存图片内容到本地文件或相册，此操作可能需要设备相关权限。 参数: callback：{Function} 在图片被写入到本地文件或相册后的回调，回调参数： result：{Object} 回调结果对象，属性列表： success：{Boolean} 标记图片是否已写入完成。 errorDesc：{String} 如果图像没有成功写入，该字符串包含了详细的错误描述。 返回值: null 注意: 你必须加入NSPhotoLibraryAddUsageDescription 和 NSPhotoLibraryAddUsageDescription (iOS 11) 以获得访问 iOS 系统相册权限. 参见: Cocoa Keys 使用 save 方法#在 &lt;image&gt;标签上增加 ref 属性 (Vue.js Child Component Refs) ： &lt;image ref=\"poster\" src=\"path/to/image.png\"&gt;&lt;/image&gt; 获取组件引用并使用 save 方法: const $image = this.$refs.poster$image.save(result =&gt; &#123; if (result.success) &#123; // Do something to hanlde success &#125; else &#123; console.log(result.errorDesc) // Do something to hanlde failure &#125;&#125;) 参见 完整例子. 事件#支持 通用事件. load#当加载完成 src 指定的图片时，load事件将被触发。 事件对象: success: {Boolean} 标记图片是否成功加载。 size: {Object} 加载的图片大小对象，属性列表： naturalWidth: {Number} 图片宽度，如果图片加载失败则为0。 naturalHeight: {Number} 图片高度，如果图片加载失败则为0。 处理 load 事件#在 &lt;image&gt; 标签上绑定 load 事件： &lt;image @load=\"onImageLoad\" src=\"path/to/image.png\"&gt;&lt;/image&gt; 增加事件处理函数： export default &#123; methods: &#123; onImageLoad (event) &#123; if (event.success) &#123; // Do something to hanlde success &#125; &#125; &#125;&#125; 参见完整示例。 样式#支持通用样式。 使用说明# 在使用 &lt;image&gt; 之前，请在 native 侧先接入相应的 adapter 或者 handler。 &lt;image&gt; 必须指定样式中的宽度和高度。 &lt;image&gt; 不支持内嵌子组件。 示例# Base64 示例 Multi-layer images 示例 Lazy load image 示例","type":"references"},{"title":"<input>","path":"cn/references/components/input.html","permalink":"https://weex.apache.org/cn/references/components/input.html","text":"&lt;input&gt;#Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 text， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 input 或 change 来代替 click 事件。 子组件#不支持子组件。 特性# type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，date，datetime，email， password，tel，time，url，number 。每个 type 值都符合 W3C 标准。 value {string}：组件的默认内容。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 return-key-type {string}：v0.11键盘返回键的类型,支持 defalut;go;next;search;send,done。 singleline {boolean}：控制内容是否只允许单行 max-length {number}：控制输入内容的最大长度 lines：控制输入内容的最大行数 max：控制当type属性为date时选择日期的最大时间，格式为yyyy-MM-dd min：控制当type属性为date时选择日期的最小时间，格式为yyyy-MM-dd 样式# placeholder-color {color}：placeholder 字符颜色。默认值是 #999999 伪类v0.9.5+: input 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 return: 键盘点击返回键。 事件中 event 对象属性： returnKeyType: 事件发生时的返回键类型。 value: 触发事件的组件的文本； 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 Methods# focus() v0.9+ focus() 方法用于将 input 组件聚焦。 blur() v0.9+ blur() 方法用于从 input 组件中移除焦点并关闭软键盘（如果它具有焦点）。 setSelectionRange(selectionStart,selectionEnd) v0.11+设置文本选区 selectionStart {number}：设置文本选区的起始点 selectionEnd {number}：设置文本选区的起终点 getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+设置文本选区 selectionStart {number}：获取文本选区的起始点 selectionEnd {number}：获取文本选区的起终点约束# 目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<list>","path":"cn/references/components/list.html","permalink":"https://weex.apache.org/cn/references/components/list.html","text":"&lt;list&gt;#&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 子组件#&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 特性# loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 示例1示例2 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 约束# 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例#加载更多","type":"references"},{"title":"<indicator>","path":"cn/references/components/indicator.html","permalink":"https://weex.apache.org/cn/references/components/indicator.html","text":"&lt;indicator&gt;#&lt;indicator&gt; 组件通常用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件#&lt;indicator&gt; 组件没有任何子组件。 样式#&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：indicator指示点未被选中时的\b颜色，默认值为 #CCCCCC item-selected-color {color}：indicator指示点被选中时的颜色，默认值为 #444444 item-size {number}：指示点的半径，默认为 5px 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width 和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件#支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束# 不支持子组件，向 indicator 中添加的所有子元素都会被忽略。 示例#查看完整示例","type":"references"},{"title":"<loading>","path":"cn/references/components/loading.html","permalink":"https://weex.apache.org/cn/references/components/loading.html","text":"&lt;loading&gt;#v0.6.1+#&lt;loading&gt; 为容器提供上拉加载功能，用法和属性与 &lt;refresh&gt; 类似。 注意：&lt;loading&gt; 是 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 的子组件，只能在被它们包含时才能被正确渲染。 简单示例： &lt;list&gt; ... ... &lt;loading&gt; ... &lt;/loading&gt;&lt;/list&gt; 查看 完整示例 子组件# 诸如 &lt;text&gt;、&lt;image&gt; 之类的任何组件，都可以放到 &lt;loading&gt; 进行渲染。 特殊子组件 &lt;loading-indicator&gt;: 只能作为 &lt;refresh&gt; 和 &lt;loading&gt; 的子组件使用，拥有默认的动画效果实现。 简单示例： &lt;loading&gt; &lt;text&gt;Loading&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/loading&gt; 查看 完整示例 属性# 属性名 类型 值 默认值 display String show / hide show display# show：如果 &lt;loading&gt; 中包含 &lt;loading-indicator&gt;，则将其显示并开始默认动画。 hide：收起 loading view，如果 &lt;loading&gt; 中包含 &lt;loading-indicator&gt;，则将其视图隐藏。 注意： display 的设置必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 简单示例： &lt;template&gt; &lt;list&gt; ... ... &lt;loading @loading=&quot;onloading&quot; :display=&quot;loadinging ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/loading&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onloading (event) &#123; this.loadinging = true setTimeout(() =&gt; &#123; this.loadinging = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; 查看 完整示例 支持所有通用属性。查看 组件通用属性 样式# 支持所有通用样式。查看 组件通用样式 事件#loading# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被上拉时触发。 查看 完整示例 示例# 完整示例","type":"references"},{"title":"<text>","path":"cn/references/components/text.html","permalink":"https://weex.apache.org/cn/references/components/text.html","text":"&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 注意： &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 注意： &lt;text&gt;不支持子组件。 属性# value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式# 支持 通用样式。 lines {number}: 指定文本行数。默认值是 0， 代表不限制行数。 支持 文本样式。 支持 color 样式. 支持 font-size 样式，默认值为32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 事件#支持 通用事件. \b自定义字体#支持版本:v0.12.0 支持ttf和woff字体格式的自定义字体, 可以通过调用 dom module 里面的 addRule方法, 构建自定义的font-family使用, addRule 建议在 beforeCreate 或者更早时调用 示例# \b&lt;text&gt;的基本用法 自定义字体的使用方法","type":"references"},{"title":"<refresh>","path":"cn/references/components/refresh.html","permalink":"https://weex.apache.org/cn/references/components/refresh.html","text":"&lt;refresh&gt;#v0.6.1+#&lt;refresh&gt; 为容器提供下拉刷新功能，用法和属性与 &lt;loading&gt; 类似。 注意：&lt;refresh&gt; 是 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 的子组件，只能在被它们包含时才能被正确渲染。 简单示例： &lt;list&gt; &lt;refresh&gt; ... &lt;/refresh&gt; ...&lt;/list&gt; 查看 完整示例 子组件# 诸如 &lt;text&gt;、&lt;image&gt; 之类的任何组件，都可以放到 &lt;refresh&gt; 进行渲染。 特殊子组件 &lt;loading-indicator&gt;: 只能作为 &lt;refresh&gt; 和 &lt;loading&gt; 的子组件使用，拥有默认的动画效果实现。 简单示例： &lt;refresh&gt; &lt;text&gt;Refreshing&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt; ...&lt;/refresh&gt; 查看 完整示例 属性# 属性名 类型 值 默认值 display String show / hide show display# show：如果 &lt;refresh&gt; 中包含 &lt;loading-indicator&gt;，则将其显示并开始默认动画。 hide：收起 refresh view，如果 &lt;refresh&gt; 中包含 &lt;loading-indicator&gt;，则将其视图隐藏。 注意： display 的设置必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 简单示例： &lt;template&gt; &lt;list&gt; &lt;refresh @refresh=&quot;onrefresh&quot; :display=&quot;refreshing ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; ... &lt;/refresh&gt; ... &lt;/list&gt;&lt;/template&gt;&lt;script&gt; ... methods: &#123; onrefresh (event) &#123; this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, &#125;&lt;/script&gt; 查看 完整示例 支持所有通用属性。查看 组件通用属性 样式# 支持所有通用样式。查看 组件通用样式 事件#refresh# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被下拉时触发。 pullingdown v0.6.1+# 当 &lt;scroller&gt;、&lt;list&gt;、&lt;hlist&gt;、&lt;vlist&gt;、&lt;waterfall&gt; 被下拉时触发，可以从 event 参数对象中获取 dy, pullingDistance, viewHeight, type dy: 前后两次回调滑动距离的差值 pullingDistance: 下拉的距离 viewHeight: refresh 组件高度 type: “pullingdown” 常数字符串 简单示例： &lt;scroller&gt; &lt;refresh @refresh=&quot;onrefresh&quot; @pullingdown=&quot;onpullingdown&quot;&gt; ... &lt;/refresh&gt; ...&lt;/scroller&gt;&lt;script&gt; export default &#123; methods: &#123; onrefresh (event) &#123; ... &#125;, onpullingdown (event) &#123; console.log(&quot;dy: &quot; + event.dy) console.log(&quot;pullingDistance: &quot; + event.pullingDistance) console.log(&quot;viewHeight: &quot; + event.viewHeight) console.log(&quot;type: &quot; + type) &#125; &#125; &#125;&lt;/script&gt; 查看 完整示例 示例# 完整示例","type":"references"},{"title":"<scroller>","path":"cn/references/components/scroller.html","permalink":"https://weex.apache.org/cn/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性# show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 scroll-direction定义了 scroller 的滚动方向，flex-direction 定义了 scroller 的布局方向，两个方向必须一致。 scroll-direction 的默认值是 vertical, flex-direction 的默认值是 row。 当需要一个水平方向的 scroller 时，使用 scroll-direction:horizontal 和 flex-direction: row。 当需要一个竖直方向的 scroller 时，使用 scroll-direction:vertical 和 flex-direction: column。由于这两个值均是默认值，当需要一个竖直方向的 scroller 时，这两个值可以不设置。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 该属性已废弃，请使用resetLoadmore()函数实现重置loadmore的操作。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 参见 scroll event demo。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 约束#不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<slider>","path":"cn/references/components/slider.html","permalink":"https://weex.apache.org/cn/references/components/slider.html","text":"&lt;slider&gt;#&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性# auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 infinite {boolean}：循环播放，可选值为 true/false，默认的是 true。 offset-x-accuracy {number}0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间Slider Page至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。体验一下事件中 event 对象属性： offsetXRatio {number}：表示当前页面的偏移比例，取值范围为[-1, 1]，负值表示向左侧滚动，正值向右。例如，-0.2表示当前item有20%的区域被滚动到slider左侧边界以外，0.3表示当前item有30%的区域被滚动到slider右侧边界以外。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<textarea>","path":"cn/references/components/textarea.html","permalink":"https://weex.apache.org/cn/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件#textarea 组件不支持子组件。 特性# value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：表示是否在页面加载时控件自动获得输入焦点。 rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式# 伪类v0.9.5+: textarea 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"cn/references/components/video.html","permalink":"https://weex.apache.org/cn/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件# &lt;text&gt; 是唯一合法的子组件。 特性# src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<waterfall>","path":"cn/references/components/waterfall.html","permalink":"https://weex.apache.org/cn/references/components/waterfall.html","text":"waterfall#v0.11.0+ 提供瀑布流布局的组件 子组件#注意: 和list一样, waterfall 只支持特定类型的组件: cell, header, refresh, loading 和 fixed-position 组件. cell: 瀑布流中的每个元素 header: 主要用于表示横跨多列的元素，可以通过css的position属性设置为sticky 特性# column-width : 描述瀑布流每一列的列宽 auto: 意味着列宽是被其他属性所决定的(比如 column-count) &lt;length&gt;: 最佳列宽，实际的列宽可能会更宽(需要填充剩余的空间)， 或者更窄(如果剩余空间比列宽还要小)。 该值必须大于0 column-count: 描述瀑布流的列数 auto: 意味着列数是被其他属性所决定的(比如 column-width) &lt;integer&gt;: 最佳列数，column-width 和 column-count 都指定非0值， 则 column-count 代表最大列数。 column-gap: 列与列的间隙. 如果指定了 normal ，则对应 32. 其他支持的属性参见 List Component Attributes 样式#通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 API#滚动到列表某个指定项是常见需求，&lt;waterfall&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt; 或者 &lt;header&gt;。通过 dom module 访问，更多信息可参考 dom module 。 示例#参见 playground waterfall example","type":"references"},{"title":"<web>","path":"cn/references/components/web.html","permalink":"https://weex.apache.org/cn/references/components/web.html","text":"v0.5+ &lt;web&gt; 用于在 weex 页面中显示由 src 属性指定的页面内容。您还可以使用 webview 模块来控制 WebView 的行为，例如回退、前进和重新加载，更多信息请参见 webview module。 基本用法# 注意： &lt;web&gt; 不支持任何嵌套的子组件，并且必须指定 width 和 height 的样式属性，否则将不起作用。 &lt;web src=\"https://vuejs.org\"&gt;&lt;/web&gt; 参见示例. 属性# 属性 类型 值 默认值 src String {URL} - src#要加载的网页内容的 URL。您可以指定一个基于 bundle URL 的相对 URL，它将被重写为真实资源 URL（本地或远程）。另请参阅：Path。 事件#只支持公共事件中的 appear 和 disappear 事件。 pagestart#pagestart 事件，会在 Web 页面开始加载时调用。 事件对象： url: {String} 当前 Web 页面的 URL。 pagefinish#pagefinish 事件，会在 Web 页面完成加载时调用。 事件对象： url: {String} 当前 Web 页面的 URL。 canGoBack: {Boolean} 当前 Web 页面是否可以回退。 canGoForward: {Boolean} 当前 Web 页面是否可以前进。 title: {String} 当前 Web 页面的标题（仅限 iOS 平台）。 error#error 事件，会在 Web 页面加载失败时调用。 receivedtitle#error 事件，会在 Web 页面的标题发生改变时调用（仅限 Android 平台）。 事件对象： url: {String} 当前 Web 页面的 URL。 处理 &lt;web&gt; 事件#在 &lt;web&gt; 上绑定事件： &lt;web @pagestart=\"onPageStart\" @pagefinish=\"onPageFinish\" @error=\"onError\" src=\"https://vuejs.org\"&gt;&lt;/web&gt; 添加事件 handler： export default &#123; methods: &#123; onPageStart (event) &#123; // page start load &#125;, onPageFinish (event) &#123; // page finish load &#125;, onError (event) &#123; // page load error &#125;, &#125;&#125; 参见示例。 样式#支持公共样式。 使用注意事项# 必须指定 &lt;web&gt; 的 width 和 height 样式。 &lt;web&gt; 不能包含任何嵌套的子组件。 您可以使用 webview module 来控制 &lt;web&gt; 组件，参见示例。 示例# 浏览器示例","type":"references"},{"title":"<switch>","path":"cn/references/components/switch.html","permalink":"https://weex.apache.org/cn/references/components/switch.html","text":"v0.6.1+ &lt;switch&gt; 是个类似 checkbox 的 UI 注意: switch 组件的外观在三个平台（iOS, Android, Web）稍有不同，这和各平台的 UI 风格有关。 Android Web iOS 注意: switch 不支持一些涉及布局的样式， 如 width, height, margin 等，下面有详细的样式不支持列表. 基本用法#&lt;switch&gt;&lt;/switch&gt; 参考示例. 特性# Attribute Type Value Default Value checked Boolean true / false false disabled Boolean true / false false checked#表示组件的选中状态。 disabled#表示组件是否处于不可交互状态。 组件方法#无。 事件# change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 样式# 注意: 某些样式在 switch 组件上不能使用或使用无效，它们是： width height min-width min-height margin 和 margin-xxx padding 和 padding-xxx border 和 border-xxx 注意: 如果 &lt;switch&gt; 的容器没有设置为 align-items：flex-start，则 Android 中的开关将被拉伸。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 使用说明# 不要设置样式 width and height，因为它们用在 &lt;switch&gt; 上不会影响该组件的外观和布局. &lt;switch&gt; 不支持内嵌子组件. 示例# 简单示例 各种状态的 switch","type":"references"},{"title":"animation","path":"cn/references/modules/animation.html","permalink":"https://weex.apache.org/cn/references/modules/animation.html","text":"动画#简介#animation 模块可以用来在组件上执行动画。 JS-Animation可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。 举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 注意： 现在Weex只支持在JavaScript中使用动画, CSS 动画是和JavaScript 动画是不一样的。我们即将支持在CSS中使用动画。 基本用法#animation.transition(el, options, callback)#animation.transition(ref1, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(250px, 100px)', &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) 属性#el：#将要执行动画的元素。 例如指定动画的元素 el 属性为 test , 可以通过调用 this.refs.test 来获取元素的引用。 options：# styles(object):设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 width 动画执行后应用到组件上的宽度值 length 无 height 动画执行后应用到组件上的高度值 length 无 backgroundColor 动画执行后应用到组件上的背景颜色 string none opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 transform同时也有很多对应的属性，可以参见下表： 名称 描述 值类型 默认值 translate/translateX/translateY 指定元素要移动到的位置 像素值或百分比 无 rotate 指定元素将被旋转的角度，单位是度 number 无 scale/scaleX/scaleY 按比例放大或缩小元素 number 无 rotate/rotateX v0.14+ /rotateY v0.14+ 指定元素将被旋转的角度，单位是度 number 无 perspective v0.16+ 观察者距离z=0平面的距离，在Android 4.1及以上有效 number 正无穷 duration(number)：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 delay (number)：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 needLayout (boolean)：节点动画执行时是否产生布局动画即LayoutAnimation，默认值是false。 timingFunction (string)：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 linear 动画从头到尾的速度是相同的 ease 动画速度逐渐变慢 ease-in 动画速度由慢到快 ease-out 动画速度由快到慢 ease-in-out 动画先加速到达中间点后减速到达终点 cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. callback#callback是动画执行完毕之后的回调函数。在iOS平台上，你可以获取动画执行是否成功的信息。 注意: 在0.16.0+版本后，iOS上可以获取animation是否执行成功的信息，callback中的result参数会有两种，分别是是Success与Fail，Android目前暂不支持。 示例#animation demo","type":"references"},{"title":"clipboard","path":"cn/references/modules/clipboard.html","permalink":"https://weex.apache.org/cn/references/modules/clipboard.html","text":"clipboard 剪切板#v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。但是现在我们可以通过简单的调用 clipboard.getString() 接口来获取短信内容了。 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 API#getString(callback)#从系统粘贴板读取内容。 参数# callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 setString(text)#将一段文本复制到剪切板，相当于手动复制文本。 参数# text {string}：要复制到剪切板的字符串。 Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"cn/references/modules/dom.html","permalink":"https://weex.apache.org/cn/references/modules/dom.html","text":"dom#dom 模块用于对 weex 页面里的组件节点进行一部分特定操作。 你可以使用该模块来获取某个组件的 bounding rect 布局信息，或者将 list 的某个子节点滚动到当前视口，或者添加一个 font-face rule，等等。 Note: API addRule 目前仅支持添加 ‘font-face’. API#scrollToElement(ref, options)#让页面滚动到 ref 对应的组件，这个 API 只能用于可滚动组件的子节点，例如 &lt;scroller&gt;，&lt;list&gt; 等可滚动组件中。 要在你的 .vue 文件中使用这个 API，可以使用 weex.requireModule(&#39;dom&#39;).scrollToElement。 参数# ref {Node}：你要滚动到的那个节点 options {Object}: offset {number}: 一个到其可见位置的偏移距离，默认是 0 animated {boolean} 0.10+：是否需要附带滚动动画，默认是true 示例#滚动到某层 getComponentRect(ref, callback) v0.9.4+#支持版本: &gt;=0.9.4 通过标签的 ref 获得其布局信息，返回的信息在 callBack 中，格式参考如下： &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; 如果想要获取到 Weex 视口容器的布局信息，可以指定 ref 为字符串 &#39;viewport&#39;，即 getComponentRect(&#39;viewport&#39;, callback). 示例#获取 box 的布局信息 addRule(type, contentObject) v0.12.0+#支持版本: &gt;=0.12.0 addRule是可以为dom 添加一条规则，目前支持自定义字体fontFace规则，构建自定义的font-family，可以在text使用 fontFace#const domModule = weex.requireModule('dom')domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;) 示例#add rule fontface","type":"references"},{"title":"globalEvent","path":"cn/references/modules/globalevent.html","permalink":"https://weex.apache.org/cn/references/modules/globalevent.html","text":"全局事件#0.8 globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件#API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#注册全局事件。 参数# eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#取消事件监听。 参数# eventName {string}：需要取消的事件名称。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"meta","path":"cn/references/modules/meta.html","permalink":"https://weex.apache.org/cn/references/modules/meta.html","text":"meta#meta 模块可用于声明单个页面的元信息，通常是一些页面的配置，如容器的显示宽度 (viewport) 等。 API#setViewport(options)#0.10.0+ Weex 容器默认的宽度 (viewport) 是 750px，通过 setViewport 方法可以改变页面的显示宽度，仅对当前页面生效。 需要注意的是：只有在页面渲染开始之前设置 viewport 才会生效。 也就是说，setViewport 方法只能在入口文件中使用，而且要在 new Vue(...) 之前调用；如果是在组件中使用，就只有在渲染到该组件的时候才会执行相应的代码，此时页面已经处于渲染过程中，设置 viewport 将不会再生效。 参数#参数配置借鉴了 W3C 标准中的 CSS Device Adaptation，目前支持如下属性： options: viewport 的配置项 width: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 height: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 宽度和高度的单位默认是 px，暂不支持其他单位。 例子#入口文件： // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// 配置 viewport 的宽度为 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) 在入口文件中配置了 viewport 的宽度为 640 之后，当前页面中的所有组件都会以 640px 作为满屏宽度。 组件文件： &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; 试试看。（由于 http://dotwe.org 目前还不支持配置入口文件，例子中的效果暂时无法在线查看。） 本地开发环境的搭建可以参考：《搭建开发环境》。","type":"references"},{"title":"navigator","path":"cn/references/modules/navigator.html","permalink":"https://weex.apache.org/cn/references/modules/navigator.html","text":"navigator 导航控制#v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 API#push(options, callback)#把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数# options {Object}：选项参数 url {stirng}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 pop(options, callback)#把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数# options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"modal","path":"cn/references/modules/modal.html","permalink":"https://weex.apache.org/cn/references/modules/modal.html","text":"modal 模态#modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 API#toast(options)#toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数# options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） Android: 如果时间长度大于3s，将使用一个被称为LONG的系统变量, 否则使用SHORT这个系统变量 iOS: 持续的时间同Duration相同 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.toast(&#123; message: &apos;This is a toast&apos;, duration: 0.3&#125;) alert(options, callback)#警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数# options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.alert(&#123; message: &apos;This is a alert&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;alert callback&apos;, value)&#125;) confirm(options, callback)#确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数# options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.confirm(&#123; message: &apos;Do you confirm ?&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;confirm callback&apos;, value)&#125;) prompt(options, callback)#提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数# options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下： result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 基本用法#var modal = weex.requireModule(&apos;modal&apos;)modal.prompt(&#123; message: &apos;This is a prompt&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;prompt callback&apos;, value)&#125;) 示例#Modal demo","type":"references"},{"title":"picker","path":"cn/references/modules/picker.html","permalink":"https://weex.apache.org/cn/references/modules/picker.html","text":"picker#v0.9+ 概述#以下为 picker 相关的 API，用于数据选择，日期选择，时间选择。（ H5模块如需使用，请手动引入weex-picker组件） API#pick(options, callback[options])#调用单选 picker 参数# options {Object}：调用单选 picker 选项 index {number}：默认选中的选项 items {array}：picker 数据源 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {number}：选择的选项,仅成功确认时候存在。 pickDate(options, callback[options])#调用 date picker 参数# options {Object}：调用 date picker 选项 value {string}：必选，date picker 选中的值，date 的字符串格式为yyyy-MM-dd max {string}：可选，date 的最大值 min {string}：可选，date 的最小值 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：选择的值 date 的字符，格式为 yyyy-MM-dd, 仅成功确认的时候存在。 pickTime(options, callback[options])#调用 time picker 参数# options {Object}：调用 time picker 选项 value {string}：必选，time 格式为 HH:mm callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：time 格式为 HH:mm, 仅成功确认的时候存在。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"stream","path":"cn/references/modules/stream.html","permalink":"https://weex.apache.org/cn/references/modules/stream.html","text":"stream#概述#以下为 stream 相关的 API，用于实现网络请求。 API#fetch(options, callback[,progressCallback])#发起网络请求 参数# options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：响应类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 注意# 默认 Content-Type 是 ‘application/x-www-form-urlencoded’。 如果你需要通过 POST json ， 需要将 Content-Type 设为 ‘application/json’。 Example#stream demo","type":"references"},{"title":"storage","path":"cn/references/modules/storage.html","permalink":"https://weex.apache.org/cn/references/modules/storage.html","text":"storage 本地存储#v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 API#storage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)#该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数# key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)#传入键名返回对应的键值 参数# key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined removeItem(key, callback)#传入一个键名将会删除本地存储中对应的键值 参数# key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 length(callback)#返回本地存储的数据中所有存储项数量的整数 参数# callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 getAllKeys(callback)#返回一个包含全部已存储项键名的数组 参数# callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it 其它参考# W3school: html5 localStorage storage 模块完整的 Demo","type":"references"},{"title":"webSocket","path":"cn/references/modules/websocket.html","permalink":"https://weex.apache.org/cn/references/modules/websocket.html","text":"webSocket#v0.12+ Summary#WebSockets 是一种先进的技术, 这使得在用户的 H5/iOS/Android 和一个服务器之间打开一个的交互式通信会话成为可能, 有了这个 API，你可以向服务器发送消息, 并接收事件驱动的响应, 无需轮询服务器的响应 注意：# iOS和h5提供 WebSockets 的 protocol 默认实现，安卓使用需要提供自定义 adapter 实现，source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; 集成例子参考weex playground API#WebSocket(url, protocol)#创建 WebSockets，并连接服务器 Arguments# url {string}: 表示要连接的 URL; protocol {string}: WebSockets 协议 send(data)#通过WebSocket连接向服务器发送数据 Arguments# data{string}:要发送到服务器的数据 close(code,reason)#关闭 WebSockets 的链接 Arguments# code {number}: 关闭连接的状态号. reason {string}: 关闭的原因 onopen(options)#链接打开的监听 Arguments# options {object}: 一个空的对象 onmessage(options)#消息事件的监听器 Arguments# options {object}: 服务器返回的消息对象 data {string}: 监听器接收的到的消息 onclose(options)#关闭事件的监听器 Arguments# options {object}: 监听器接收到的对象 code {number}: 服务器返回关闭的状态码 reason {string}: 服务器返回的关闭原因 wasClean {boolen}: 是否完全关闭. onerror(options)#错误事件的监听器 Arguments# options {object}: 错误信息的事件 data {string}: 监听器接收到的信息 Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"cn/references/modules/webview.html","permalink":"https://weex.apache.org/cn/references/modules/webview.html","text":"webview 模块提供了一系列的 &lt;web&gt; 组件操作接口，例如 goBack、goForward、和 reload。一般与 &lt;web&gt; 组件一起使用。 API#goBack(webElement)#前往 WebView 历史记录的上一页。 参数 webElement(web): &lt;web&gt; 组件元素。 goForward(webElement)#前往 WebView 历史记录的下一页。 参数 webElement(web): &lt;web&gt; 组件元素。 reload(webElement)#刷新当前 Web 页面。 参数 webElement(web): &lt;web&gt; 组件元素。 示例# 简单用法： var webElement = this.$el('webview');var webview = weex.requireModule('webview');webview.goBack(webElement.ref);webview.goForward(webElement.ref);webview.reload(webElement.ref); 浏览器示例","type":"references"}],"posts":[{"title":"Weex ❤️ iOS 11 系列之二：ARKit初探","path":"en/arkit/","link":"","permalink":"https://weex.apache.org/en/arkit/","text":"ARKit#苹果在wwdc 2017公布了第一款具有AR功能的操作系统iOS11，并提供了AR的SDK，ARKit，同时宣称苹果是世界上最大的AR平台，Weex也积极拥抱AR，让Weex用户也可以方便开发AR功能 AR体验就是创建和追踪用户所在的现实世界和可建立模型的空间的对应关系的能力，让用户感觉产生虚拟内容在现实世界的错觉，这就是所谓的增强现实。ARKit通过识别图像场景中的显著特征，追踪这些特征的差异位置，最后与传感器数据比较，得到设备位置和运动状态的高精度模型 原理#ARkit 在ARSCNView，ARSession,ARFrame的基础上实现 ARSCNView和ARSession#ARKit提供了两种增强现实的视图，他们分别是ARSCNView(3D)和ARSKView(2D),这两种视图都采用ARCamera作为视图背景的，而ARSCNView等视图和相机没有直接关系，他们是通过ARSession这个桥梁和camera交互的，运行一个session，需要指定会话追踪配置的对象：ARSessionConfiguration，ARSessionConfiguration负责追踪相机在3D世界中的位置和平面探测 ARWorldTrackingSessionConfiguration与ARFrame#ARWorldTrackingSessionConfiguration通过一系列的复杂计算和调用传感器来跟踪设备的方向和位置，当ARWorldTrackingSessionConfiguration计算出位置，会交给ARSession管理,ARSession就会维护一个相机的位置ARFame，用户可以通过这个frame将4x4矩阵世界坐标转换为3D系统相机坐标 weex-ar#ARKit在wwdc上带来的震撼效果，我通过weex插件的方式将ARKit能力透传到Weex，让用户在weex上也第一时间体验到Native的AR效果所有的demo以及源码我已经开源，同步到github，用户在自己工程依赖即可使用 在现实世界渲染一个3D的虚拟物体#this.$refs[&apos;scene&apos;].addNode(&#123; name:&apos;color&apos;, width:0.1, height:0.1, length:0.1, chamferRadius:0, vector:&#123; x:0.1, y:0.1, z:-0.5 &#125;, contents:&#123; type:&apos;color&apos;, name:&apos;red&apos; &#125; &#125;); Weex在compnonent中增加addNode方法，用户可以设置好节点的参数，然后就会构建一个虚拟物体 效果 交互支持#当native触发了点击事件，会向jsfm发送点击位置信息 -(void)tapped:(UITapGestureRecognizer *)recognizer&#123; SCNView *sceneView = (SCNView *)recognizer.view ; CGPoint touchLocation = [recognizer locationInView:sceneView]; [self fireEvent:@&quot;tap&quot; params:@&#123;@&quot;touchLocation&quot;:@&#123;@&quot;x&quot;:@(touchLocation.x),@&quot;y&quot;:@(touchLocation.y)&#125;&#125;];&#125; 当VUE接收到相关信息，会处理位置信息，然后更新节点tap:function (event) &#123; this.index = this.index+1; if(this.index&gt;3)&#123; this.index = 0; &#125; var color = &apos;red&apos;; if(this.index == 1)&#123; color = &apos;blue&apos;; &#125; if(this.index == 2)&#123; color = &apos;green&apos;; &#125; if(this.index == 3)&#123; color = &apos;yellow&apos;; &#125; this.$refs[&apos;scene&apos;].updateNode(&#123; name:&apos;color&apos;, x:event.touchLocation.x, y:event.touchLocation.y, color:color &#125;) &#125; 效果 碰撞游戏#设置节点的mask，通过arkit的代理就可以检测碰撞了node.physicsBody.categoryBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;categoryBitMask&quot;]]]; node.physicsBody.contactTestBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;contactTestBitMask&quot;]]]; 当碰撞发生时候，会通过physicsWorld:(SCNPhysicsWorld )world didBeginContact:(SCNPhysicsContact )contact代理获取到节点的信息，weex将相关信息发送到jsfmvue获取先关节点可以删除节点，增减节点，从而完成碰撞的处理contact:function (event) &#123; if(event.nodes.nodeA.mask == 0 || event.nodes.nodeB.mask == 0 )&#123; this.isAdd = false; this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeA.name); this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeB.name); &#125; &#125; 效果","type":"blog"},{"title":"Weex ❤️ iOS 11 系列之一：Core ML 初探","path":"en/coreml/","link":"","permalink":"https://weex.apache.org/en/coreml/","text":"背景#WWDC 2017 有一个非常明确的信号：端上机器学习将会是未来苹果的一个重要发力点，同时开发者的使用门槛在不断降低。 Core ML 是今年 WWDC 上苹果发布的机器学习框架。它允许开发者在自己开发的 app 上使用机器学习，同时不需要收集用户数据。 有了 Core ML，你可以将自己训练得到的模型，借助苹果提供的转换工具，转化成 Core ML 类型的模型文件，你可以非常轻松地直接实现模型和 app 数据的互通。 WWDC 上展示了一张简单的架构图： 最底层的 Accelerate 和 MPS，其实是苹果去年推出的接口，前者可以直接调用 CPU，后者则直接调用 GPU。 Core ML 会自行决定到底使用 CPU 还是 GPU 来进行运算，可以最大程度地利用硬件资源来处理模型数据。 而 Core ML 往上一层则是应用层。Vision 主要负责图像相关的人工智能处理，如人脸识别、面部追踪、文字识别等等；NLP 则提供语义分析相关 API。这部分内容在以前版本的 SDK 中也存在，这次被集成到了新框架当中。好处在于，开发者拥有了更大的自由度。在以前，开发者的 app 调用这些高级接口，对底层的实现细节的掌控力度非常小。现在，你可以通过自定义底层所使用的机器学习模型，从而实现更个性化的需求。 Weex-ML#Weex 交互视觉能力小结中提到，Weex 最大的特别之处在于其 native 的能力， 我们要最大化利用 native 的特性， 而不是去模仿它。 作为本次 iOS 11 的一个重要 native 能力，我也第一时间尝试将 Core ML 透传到了 Weex 上。所有代码和 Demo 都已开源到 Github，后续也会将机器学习相关的Weex 模块统一放到 Weex Market 上。 得益于 Core ML API 的简洁，在 Weex 上使用 Core ML 相关能力变得非常简单: let imageRecognition = weex.requireModule('imageRecognition')imageRecognition.predictWithImage(this.$refs.image.ref, (results)=&gt;&#123; this.results = results.slice(0,5);&#125;) 通过调用透传的 module imageRecognition , 并传入 image 组件的 ref 作为参数，就可以实现图片识别的功能，最后提取出识别结果中 confidence 最高的 5 个结果。 Demo#imageRecognition# 使用 Inceptionv3 作为模型，能够高效识别， 该模型已经在 keras 中被训练好并通过苹果提供的工具转换成 mlmodel 文件， 只需拖拽的方式就可以集成到 iOS 开发环境中， 上述 demo 输出了对一张图片分类最大可能的5个预测结果， 对于 Weex 来说，几行代码就能搞定。 digitDetect# 上述 demo 首先使用 weex-gcanvas 插件做了一个简单的绘制板，然后使用 MNIST model 完成了对手写数字的识别。 faceDetect# 这个 demo 没有加载任何 model，使用了 iOS 11 内置的 Vision Framework，顾名思义，Vision 可以让开发者运行计算机视觉相关的任务，它相当于 Core ML 的 High-Level Solution， 它可以做很多事情: 脸部识别，会返回一个矩形数组来表示每一个脸部 脸部更精细识别，比如眼睛和鼻子的具体位置、头部的形状等，上述 demo 就是拿到这些信息以后使用 gcanvas 绘制出了面部精细轮廓 图片中的矩形探测 图片中的文字探测 二维码/条形码探测 视频中跟踪移动的物体 总结#这次 Core ML 的推出，同时得益于苹果对软硬件的全面掌控，使得从系统级到第三方开发者，都具备了在端上就可以进行机器学习模型处理的能力。所有代码和 Demo 都已上传到 Github，欢迎贡献和交流。 当然在实际研究过程中，也发现了 Core ML \u0005的一些限制： 无法在端上进行模型的训练，所有模型必须提前训练好再转换成 Core ML 的格式 无法动态下载和更新模型，对于需要经常重新训练的模型不太友好 目前看只支持监督学习的模型，不支持非监督学习。 Weex 未来在提供更多功能透传的同时，也会继续探索更深层次的结合。 最后，本文是 Weex 和 iOS 11 结合系列的第一篇文章，后续将会有更多有意思的iOS 11 feature (如 ARKit、 drag &amp; drop 等) 和大家一起探讨。","type":"blog"}]}